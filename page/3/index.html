<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.0.1">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=7.0.1" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true,"dimmer":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script>
  (function(i,s,o,g,r,a,m){i["SlardarMonitorObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date;a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://i.snssdk.com/slardar/sdk.js?bid=debugtalk","Slardar");
</script>
<script>
  window.Slardar('config', {
    sampleRate: 1,
    bid: 'debugtalk',
    ignoreAjax: [],
    ignoreStatic: [],
    hookFetch: true,
    enableSizeStats: true
  });
  window.Slardar('send', 'pageview');
</script>



  

<script>
  (function(i,s,o,g,r,a,m){i["SlardarMonitorObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date;a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://i.snssdk.com/slardar/sdk.js?bid=debugtalk","Slardar");
</script>
<script>
  window.Slardar('config', {
    sampleRate: 1,
    bid: 'debugtalk',
    ignoreAjax: [],
    ignoreStatic: [],
    hookFetch: true,
    enableSizeStats: true
  });
  window.Slardar('send', 'pageview');
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="DebugTalk">
<meta property="og:url" content="https://debugtalk.com/page/3/index.html">
<meta property="og:site_name" content="DebugTalk">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DebugTalk">



  <link rel="alternate" href="/atom.xml" title="DebugTalk" type="application/atom+xml">




  <link rel="canonical" href="https://debugtalk.com/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>DebugTalk</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=[object Object]"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-81639610-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DebugTalk</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">探索一个软件工程师的无限可能</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/debugtalk" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/my-2017-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/my-2017-summary/" class="post-title-link" itemprop="url">我的 2017 年终总结</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-31T00:00:00+08:00">2017-12-31</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/5-Growth/" itemprop="url" rel="index"><span itemprop="name">5. Growth</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/5-Growth/年终总结/" itemprop="url" rel="index"><span itemprop="name">年终总结</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2017年已经结束了，为了给以后的自己留点回忆，还是写篇博客记录下吧。</p>
<p>先从工作说起吧。这一年，我依然在大疆的互联网事业部做测试开发岗位。有点变化的是，年初是自己一个人做，然后逐步有新的伙伴加入，成立了测试开发小组，并担任了小组负责人。简单地说，就是除了纯技术，也开始兼具了一点技术管理的角色，这对于我个人也是一个挺大的转变。看过我个人博客自我介绍的同学都知道，“在墙角安静地写代码才是我的最爱”，所以我对于做管理是一直都挺抗拒的。不过，后来通过阅读一些互联网前辈的文章（主要有池建强老师、左耳朵耗子皓叔、硅谷女神安姐等），再加上leader的循序善诱，我的想法也发生了一些转变。我渐渐地也开始认同，技术管理与做好技术并不冲突，但发挥团队的力量，却可以做更大的事情，产生更大的价值。同时，担任技术管理也意味着多了一份责任，自己不能再由着个人喜好去摸索一些看似酷炫实则无用的“黑科技”，而应时刻关注技术转化的业务价值，这不管是对于公司还是个人，都是至关重要的。</p>
<p>在大疆除了测试开发工作，我还负责一些重要节点的性能压测工作。今年最大的一次压测应该就是准备5月24日的<a href="https://www.dji.com/products/spark?site=brandsite&from=nav" target="_blank" rel="noopener"><code>Spark</code></a>新品发布了。在这个项目中，我担任性能测试总负责人，负责PC商城、手机商城、官网、直播系统、支付中心等相关电商系统的整体性能测试工作。当然，那段时间加班也挺多的，以至于我后面出差到达纽约发布会现场都不用倒时差了。说到出差，感谢领导和同事的信任，让我去发布会现场做直播系统的技术支持，我也有机会第一次去到美国，这个我一直特别想去体验的国家。现在回想起来，当时也真是人品爆发，在办美国商务签证的时候很顺利地就通过了（可怜我的另两位同事，他们虽然都准备得非常充分，但后来去办签证的时候都进了审核）；另外，当时自己因为疏忽，忘了<code>eVUS</code>这么一个东西，结果去登机时才被告知必须要提前完成<code>eVUS</code>的登记审核，搞得我一脸懵逼，所幸当时立即提交申请后居然很快就审批通过了，不然差点就真错过了。</p>
<p>当时到纽约完成了新品发布会的工作后，考虑到机会难得，我也申请了两天的假期，在纽约市区（主要就是曼哈顿区）转了下，因为时间有限，去的也都是闻名已久的地标，例如时代广场、世贸中心、帝国大厦、中央公园、自然历史博物馆等，以及远距离看了下自由女神像的侧面。对于纽约，印象是极其深刻的，如果让我用一个词来概括，那就是“大城市”，虽然在国内去的地方也不少，意大利法国的首都也去旅游过，但到纽约后真的有种进城了的感觉。当时在返程的飞机上趁着兴奋劲，还写了篇记录文章，《纽约出差之城市印象》，写了近两千字还没有收尾，结果后来拖延证一犯就一直没发出来。除了逛纽约，当时也跟多年未见的同学聚了下。一个是高中同学，在纽约大学任教，在他的带领下我也逛了下纽约大学，可惜当时天气不是特别好，没能见到草地上满是穿着比基尼晒太阳的妹子，甚是遗憾。另一个是大学室友，本来是在波士顿工作的，结果也带着媳妇儿（同是大学校友）开车五六个小时到纽约聚了下。哦对，我们聚会都是吃的中餐厅。在异国他乡与多年未见的同学相聚，叙叙旧聊聊人生，感觉还是蛮不错的。</p>
<p>今年除了到美国纽约，我还到了其它几个国家地区。还是纽约出差那次，因为国内直达的航班机票价格太高，所以我选择了中转的方式；当时就从香港机场乘机，先飞到了韩国的首尔机场，然后再转机到纽约的肯尼迪机场。当时在韩国首尔机场停歇了四五个小时，虽然没有出机场，但是在机场里面逛的地方也挺多的，除了尝下韩国本土特色小吃外，还碰到了换班的空姐，一大波韩国空姐陆陆续续从眼前走过，场景甚是壮观。除了那次出差，在年初春节的时候，跟媳妇儿和朋友媳妇一起到意大利、法国旅行度蜜月，大概12天的自由行，游玩的城市有罗马、梵蒂冈、佛罗伦萨、米兰和巴黎。当时也是第一次出国，新鲜感蛮大的，还写了一篇游记，<a href="https://debugtalk.com/post/my-impression-on-italy-and-france/">《春节旅行之意法印象》</a>。</p>
<p>再说回技术方面。今年做了一个自己还算比较满意的开源项目，<a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="noopener"><code>HttpRunner</code></a>（起初叫做<code>ApiTestEngine</code>），核心特色就是基于现有成熟的Python开源项目<a href="https://github.com/requests/requests" target="_blank" rel="noopener"><code>requests</code></a>和<a href="https://github.com/locustio/locust" target="_blank" rel="noopener"><code>Locust</code></a>，打造了一套<code>HTTP</code>测试框架，可以实现只需采用<code>YAML/JSON</code>格式维护一套脚本，就可同时实现自动化测试和性能测试。回顾今年的技术博客，有16篇文章都是围绕<code>HttpRunner</code>写的，<a href="https://debugtalk.com/tags/HttpRunner/">《HttpRunner 开发博客》</a>，可见自己在这上面投入的精力还是非常大的。值得欣慰的是，该框架产生的收效还不错，除了在大疆内部的多个项目中投入了使用，当前已知的有好几个其它公司的测试同学也都在使用这个框架。也源于开源，我在开发该框架的时候收到了非常多的反馈和建议，这对<code>HttpRunner</code>的持续优化迭代产生了非常巨大的帮助。从情感上讲，<code>HttpRunner</code>就如同自己的亲骨肉，里面融入了我自身非常多的对测试的思考，后续我也将继续不断优化<code>HttpRunner</code>，期望它能有朝一日在测试届大放异彩。</p>
<p>今年，我也在公司内外做过一些分享。一个是六月份的时候，当时公司新进了一批实习生，当时分配给我的任务是对我们质量部的岗位进行介绍，给实习生们讲解下我们测试工程师的工作日常情况。由于面向的都是新人，而且各种岗位的都有，因此也只能是科普介绍了。讲完后，我又整理下内容写了篇博客文章，<a href="https://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a>，阅读量居然还挺高。另一次分享是大疆与TesterHome合办的<a href="https://testerhome.com/topics/9755" target="_blank" rel="noopener">测试沙龙</a>，我作为其中一位分享者，演讲的主题也是围绕着<code>HttpRunner</code>，题目是《低成本实现系统接口测试 – 自动化、性能、持续集成&amp;线上监控》，从现场互动上来看，还是挺不错的。沙龙活动之后，<code>TOP100</code>的某位主编联系到我，希望我能在2017年第6届全球软件案例研究峰会上做了分享，当时想着也是个锻炼的机会，也就提交了案例，并且入了<a href="http://www.top100summit.com/think/12686" target="_blank" rel="noopener">榜单</a>；不过后来主办方的做法有些让人呵呵，在此我也不想多提了，总之最后我没去现场（虽然赠送给我一张全程票），后续应该也不会考虑与他们合作了。关于分享这块儿，比较遗憾的是错过了<code>TesterHome</code>的测试开发大会，五月份的时候思寒问我topic的时候，当时忙于公司的新品发布会没时间准备，就此错过了与诸多大佬见面的机会，只能看2018年是否还有机会了。</p>
<p>今年另一件比较有意思的事情，签订了一份图书出版合同。六月份的时候，电子工业出版社博文视点的一位编辑跟我联系，说看到我博客上的文章还不错，问我是否有兴趣出版图书。当时我既惊讶又惊喜，因为写书这事儿我之前从来没敢想过，所以一时心里也没底儿。好在陈编也给了我很多肯定和鼓励，同时我也想挑战一下自己，最后就答应了出版的事儿，并最终与博文视点签订了合同，书名暂定为《互联网系统测试精要：自动化、性能、持续集成》。合同签订后，我开始后悔自己太过乐观了，写书比我想象中难得多。因为写书只能是业余时间，有时工作太忙就完全顾不上了，等过一段时间再想提笔的时候发现手感灵感全没了。是的，别说是写书了，就是写博客，隔段时间不写再想捡起来也是异常痛苦。有过这段经历，我对书籍更多了一分敬畏，先不说书的内容质量，光是作者坚持下去的这份毅力，也是难能可贵的。还好出版社也没有给我压力，在这个过程中也给了我不少鼓励。当时签约的交稿日期是2017年12月中旬，但实际完成率嘛，嗯，希望我能在2018年尽早完成吧。</p>
<p>再说点生活上的事儿吧。今年我买了人生中的第一辆车，从此也算是有房有车了，虽然房子远在广州山区，车也不是啥好车。在买车之前，我基本对车完全不懂，可能除了奔驰宝马奥迪的车标能认出来外，其它一概不知。当时要去4S店看车之前，担心被销售看出啥也不懂的尴尬，还在汽车之家上好生科普了一番，总算对汽车有了点了解。然后就是一番小纠结，先是犹豫买SUV还是轿车，听闻20万以下的城市SUV也就那样后就决定买轿车；然后考虑轿车买A级还是B级，想到近几年也不会换车，还是一次性买个宽敞点的吧，就决定买B级车；然后就在几个品牌的B级车里选了，丰田凯美瑞、本田雅阁、雪佛兰迈锐宝、马自达阿特兹、别克君威都有看过，最后被马自达的信仰洗脑了，再加上阿特兹的颜值，从而就选定了阿特兹这款车，而且选的是骚气的魂动红，应该比较符合我闷骚的气质吧。另外，由于深圳和广州的车牌都需要摇号，拍卖价格又太高，所以就选择了在老家上牌，幸运的是选中的车牌还比较满意，<code>DBG256</code>，跟我个人的职业也比较搭。在车技这块儿，虽然我的驾照满六年都换过一次证了，但这些年摸车的确比较少，当时为了找手感，还提前在58同城上约了一个陪驾服务，师傅是一位号称有18年驾龄的资深美女。所幸经过一段时间的熟悉，现在车技已经好多了，至少刚开始时那些停车就不小心剐蹭到旁边的奔驰、上高速就手心冒汗这些心理障碍已经差不多没了。</p>
<p>2017年，一不小心就写了这么多。最后的压轴戏，当然是我刚出生的小坚果宝宝啦。刚当上爸爸，咋说呢，心情有些复杂，既兴奋又紧张。虽然是足月，而且还晚了两天才出生，但当第一次看到小家伙的时候，还是会感觉有些惊慌失措，从此我便多了一层父亲的身份，需要肩负更多的责任。还记得多年前曾和一位领导兼前辈聊人生，他跟我说工作并不是生活的全部，下班回家逗逗儿子也是挺有意思的。当时我还不能完全理解，现在我终于有了切身的体会，看着孩子的喜怒哀乐，陪伴的孩子的成长，本身就是一件非常幸福的事情。而我自身，也需要做好爸爸的榜样，言传身教还是很重要的。对于宝宝的未来，我也并没有太多期待，健康快乐地成长就好了，过两年再大点的时候，顺便再把Python学会了，嗯，徒手反转二叉树啥的技能也得学下。</p>
<p>最后按照惯例，再展望下即将来临的2018年吧。</p>
<p>1、坚持写作。博客公众号文章的更新频率得提升下，平均每月3~5篇还是要保证的。另外就是尽快把签约的书稿结了，不然就算出版社不催，我也不好意思了。</p>
<p>2、在工作上有更多的成长和产出。新的一年就迈入而立之年了，离“中年危机”也更近了一分，焦虑是没用的，踏踏实实快速成长吧。</p>
<p>3、学会生活，锻炼身体，陪伴家人，工作是长跑，讲究的是可持续发展。去年的展望也写了这句，但做的并不好，希望2018年能有所改善。</p>
<p>4、再借用下习主席的新年寄语，逢山开路，遇水搭桥，不管有啥困难，终将可以克服的。</p>
<h2 id="成长轨迹"><a href="#成长轨迹" class="headerlink" title="成长轨迹"></a>成长轨迹</h2><ul>
<li><a href="https://debugtalk.com/post/my-2016-summary/">《我的 2016 年终总结》</a></li>
<li>《我的 2015 年终总结》</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/HttpRunner-testcase-layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/HttpRunner-testcase-layer/" class="post-title-link" itemprop="url">HttpRunner 的测试用例分层机制（已过期）</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-23 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-23T00:00:00+08:00">2017-12-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>从版本 1.4 开始，测试用例分层机制已进行重新设计，本文内容不再适用。</p>
</blockquote>
<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在 <code>HttpRunner</code> 中，测试用例引擎最大的特色就是支持 <code>YAML/JSON</code> 格式的用例描述形式。</p>
<p>采用 <code>YAML/JSON</code> 格式编写维护测试用例，优势还是很明显的：</p>
<ul>
<li>相比于表格形式，具有更加强大的灵活性和更丰富的信息承载能力；</li>
<li>相比于代码形式，减少了不必要的编程语言语法重复，并最大化地统一了用例描述形式，提高了用例的可维护性。</li>
</ul>
<p>以最常见的登录注销为例，我们的测试用例通常会描述为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">demo-login-logoff</span></span><br><span class="line"><span class="attr">    variable_binds:</span></span><br><span class="line"><span class="attr">        - UserName:</span> <span class="string">test001</span></span><br><span class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        base_url:</span> <span class="attr">http://xxx.debugtalk.com</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Accept:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            User-Agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Login</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/v1/Account/Login</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            UserName:</span> <span class="string">$UserName</span></span><br><span class="line"><span class="attr">            Pwd:</span> <span class="string">$Password</span></span><br><span class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["status_code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.IsSuccess",</span> <span class="literal">True</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.Code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Logoff</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/v1/Account/LoginOff</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["status_code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.IsSuccess",</span> <span class="literal">True</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.Code",</span> <span class="number">200</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>相信大家已经对该种用例描述形式十分熟悉了。不过，该种描述形式的问题在于，接口通常会出现在多个测试场景中，而每次都需要对接口进行定义描述，包括请求的URL、Header、Body、以及预期响应值等，这就会产生大量的重复。</p>
<p>例如，在某个项目中存在三个测试场景：</p>
<ul>
<li>场景A：注册新账号（<code>API_1/2</code>）、登录新注册的账号（<code>API_3/4/5</code>）、查看登录状态（<code>API_6</code>）；</li>
<li>场景B：登录已有账号（<code>API_3/4/5</code>）、注销登录（<code>API_7/8</code>）；</li>
<li>场景C：注销登录（<code>API_7/8</code>）、查看登录状态（<code>API_6</code>）、注册新账号（<code>API_1/2</code>）。</li>
</ul>
<p>按照常规的接口测试用例编写方式，我们需要创建3个场景文件，然后在各个文件中分别描述三个测试场景相关的接口信息。示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-1.jpeg" alt></p>
<p>在本例中，接口（<code>API_1/2/6</code>）在场景A和场景C中都进行了定义；接口（<code>API_3/4/5</code>）在场景A和场景B中都进行了定义；接口（<code>API_7/8</code>）在场景B和场景C中都进行了定义。可以预见，当测试场景增多以后，接口定义描述的维护就会变得非常困难和繁琐。</p>
<h2 id="接口的分层定义描述"><a href="#接口的分层定义描述" class="headerlink" title="接口的分层定义描述"></a>接口的分层定义描述</h2><p>那要如何进行优化呢？</p>
<p>其实也很简单，在编程语言中，如果出现重复代码块，我们通常会将其封装为类或方法，然后在需要时进行调用，以此来消除重复。同样地，我们也可以将项目的API进行统一定义，里面包含API的请求和预期响应描述，然后在测试场景中进行引用即可。</p>
<p>示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-2.jpeg" alt></p>
<p>具体地，我们可以约定将项目的所有API接口定义放置在 <code>api</code> 目录下，并在 <code>api</code> 目录中按照项目的系统模块来组织接口的定义；同时，将测试场景放置到 <code>testcases</code> 目录中。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">✗ tree tests</span><br><span class="line">tests</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── Account.yml</span><br><span class="line">│       ├── BusinessTrip.yml</span><br><span class="line">│       ├── Common.yml</span><br><span class="line">│       └── Leave.yml</span><br><span class="line">├── debugtalk.py</span><br><span class="line">└── testcases</span><br><span class="line">    ├── scenario_A.yml</span><br><span class="line">    ├── scenario_B.yml</span><br><span class="line">    └── scenario_C.yml</span><br></pre></td></tr></table></figure>

<p>而对于API接口的定义，与之前的描述方式基本一致，只做了两点调整：</p>
<ul>
<li>接口定义块（<code>block</code>）的标识为 <code>api</code>；</li>
<li>接口定义块中包含 <code>def</code> 字段，形式为 <code>api_name(*args)</code> ，作为接口的唯一标识ID；需要注意的是，即使 <code>api</code> 没有参数，也需要带上括号，<code>api_name()</code>；这和编程语言中定义函数是一样的。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- api:</span></span><br><span class="line"><span class="attr">    def:</span> <span class="string">api_v1_Account_Login_POST($UserName,</span> <span class="string">$Password)</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/v1/Account/Login</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            UserName:</span> <span class="string">$UserName</span></span><br><span class="line"><span class="attr">            Pwd:</span> <span class="string">$Password</span></span><br><span class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["status_code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.IsSuccess",</span> <span class="literal">True</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.Code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- api:</span></span><br><span class="line"><span class="attr">    def:</span> <span class="string">api_v1_Account_LoginOff_GET()</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/v1/Account/LoginOff</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["status_code",</span> <span class="number">200</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.IsSuccess",</span> <span class="literal">True</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["content.Code",</span> <span class="number">200</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>有了接口的定义描述后，我们编写测试场景时就可以直接引用接口定义了。</p>
<p>同样是背景描述中的登录注销场景，测试用例就描述为变为如下形式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">    variable_binds:</span></span><br><span class="line"><span class="attr">        - UserName:</span> <span class="string">test001</span></span><br><span class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        base_url:</span> <span class="attr">http://xxx.debugtalk.com</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            Accept:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">            User-Agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Login</span></span><br><span class="line"><span class="attr">    api:</span> <span class="string">api_v1_Account_Login_POST($UserName,</span> <span class="string">$Password)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Logoff</span></span><br><span class="line"><span class="attr">    api:</span> <span class="string">api_v1_Account_LoginOff_GET()</span></span><br></pre></td></tr></table></figure>

<p>不难看出，对API接口进行分层定义后，我们在测试用例场景中引用接口定义时，与编程语言里面调用函数的形式基本完全一样，只需要指定接口的名称，以及所需传递的参数值；同样的，即使没有参数，也需要带上括号。</p>
<p>实现接口的分层定义描述后，我们就可以避免接口的重复定义。但是，我们回过头来看之前的案例，发现仍然会存在一定的重复。</p>
<p><img src="/images/httprunner-testcase-layer-3.jpeg" alt></p>
<p>如上图所示，场景A和场景C都包含了注册新账号（<code>API_1/2</code>）和查看登录状态（<code>API_6</code>），场景A和场景B都包含了登录已有账号（<code>API_3/4/5</code>），场景B和场景C都包含了注销登录（<code>API_7/8</code>）。</p>
<p>虽然我们已经将接口的定义描述抽离出来，避免了重复的定义；但是在实际业务场景中，某些功能（例如登录、注销）会在多个场景中重复出现，而该功能又涉及到多个接口的组合调用，这同样也会出现大量的重复。</p>
<h2 id="接口的模块化封装"><a href="#接口的模块化封装" class="headerlink" title="接口的模块化封装"></a>接口的模块化封装</h2><p>玩过积木的同学可能就会想到，我们也可以将系统的常用功能封装为模块（suite），只需要在模块中定义一次，然后就可以在测试场景中重复进行引用，从而避免了模块功能的重复描述。</p>
<p><img src="/images/httprunner-testcase-layer-4.jpeg" alt></p>
<p>具体地，我们可以约定将项目的所有模块定义放置在 <code>suite</code> 目录下，并在 <code>suite</code> 目录中按照项目的功能来组织模块的定义。</p>
<p>后续，我们在 <code>testcases</code> 目录中描述测试场景时，就可同时引用接口定义和模块定义了；模块和接口的混合调用，必将为我们编写测试场景带来极大的灵活性。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">✗ tree tests</span><br><span class="line">tests</span><br><span class="line">├── api</span><br><span class="line">│   └── v1</span><br><span class="line">│       ├── Account.yml</span><br><span class="line">│       ├── BusinessTrip.yml</span><br><span class="line">│       ├── Common.yml</span><br><span class="line">│       └── Leave.yml</span><br><span class="line">├── debugtalk.py</span><br><span class="line">├── suite</span><br><span class="line">│   ├── BusinessTravelApplication</span><br><span class="line">│   │   ├── approve-application.yml</span><br><span class="line">│   │   ├── executive-application.yml</span><br><span class="line">│   │   ├── reject-application.yml</span><br><span class="line">│   │   └── submit-application.yml</span><br><span class="line">│   └── LeaveApplication</span><br><span class="line">│       ├── approve.yml</span><br><span class="line">│       ├── cancel.yml</span><br><span class="line">│       └── submit-application.yml</span><br><span class="line">└── testcases</span><br><span class="line">    ├── scenario_A.yml</span><br><span class="line">    ├── scenario_B.yml</span><br><span class="line">    └── scenario_C.yml</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们在组织测试用例描述的文件目录结构时，遵循约定大于配置的原则：</p>
<ul>
<li>API接口定义必须放置在 <code>api</code> 目录下</li>
<li>模块定义必须放置在 <code>suite</code> 目录下</li>
<li>测试场景文件必须放置在 <code>testcases</code> 目录下</li>
<li>相关的函数定义放置在 <code>debugtalk.py</code> 中</li>
</ul>
<p>至此，我们实现了测试用例的 <code>接口-模块-场景</code> 分层，从而彻底避免了重复定义描述。</p>
<h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>得益于约定大于配置的原则，在 <code>HttpRunner</code> 中实现了一个脚手架工具，可以快速创建项目的目录结构。该想法来源于 <code>Django</code> 的 <code>django-admin.py startproject project_name</code>。</p>
<p>使用方式也与 <code>Django</code> 类似，只需要通过 <code>--startproject</code> 指定新项目的名称即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hrun --startproject helloworld</span><br><span class="line">INFO:root: Start to create new project: /Users/Leo/MyProjects/helloworld</span><br><span class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld</span><br><span class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests</span><br><span class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/api</span><br><span class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/suite</span><br><span class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/testcases</span><br><span class="line">INFO:root:      created file: /Users/Leo/MyProjects/helloworld/tests/debugtalk.py</span><br></pre></td></tr></table></figure>

<p>运行之后，就会在指定的目录中生成新项目的目录结构，接下来，我们就可以按照测试用例的 <code>接口-模块-场景</code> 分层原则往里面添加用例描述信息了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果看到这里你还不明白测试用例分层的必要性，那也没关系，测试用例分层不是必须的，你还是可以按照之前的方式组织测试用例。不过当你某一天发现需要进行分层管理时，你会发现它就在那里，很实用。</p>
<p>最后，在 <code>HttpRunner</code> 项目的 <a href="https://github.com/HttpRunner/HttpRunner/tree/master/examples/HelloWorld" target="_blank" rel="noopener"><code>examples/HelloWorld</code></a> 目录中，包含了一份完整的分层测试用例示例，相信会对大家有所帮助。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/HttpRunner-validator-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/HttpRunner-validator-optimization/" class="post-title-link" itemprop="url">HttpRunner 的结果校验器优化</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2017-12-13T00:00:00+08:00">2017-12-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在测试用例中，包含预期结果这么一项，用于辅助测试人员执行测试用例时判断系统的功能是否正常。而在自动化测试中，我们的目标是让测试用例自动执行，因此自动化测试用例中同样需要包含预期结果一项，只不过系统响应结果不再由人工来进行判断，而是交由测试工具或框架来实现。</p>
<p>这部分功能对应的就是测试结果校验器（validator），基本上能称得上自动化测试工具或框架的都包含该功能特性。</p>
<h2 id="设计之初"><a href="#设计之初" class="headerlink" title="设计之初"></a>设计之初</h2><p><code>HttpRunner</code>在设计之初，结果校验器（validator）的实现比较简单。</p>
<p>对于每一个<code>test</code>，可以指定0个或多个校验项，放置在<code>validate</code>中。在自动化测试执行的时候，会在发起HTTP请求、解析结果响应之后，逐个检查各个校验项，若存在任意校验项不通过的情况，则该<code>test</code>将终止并被标记为失败。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    extract:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如上例所示，每一个校验项均为一个<code>json</code>结构，里面包含<code>check</code>、<code>expect</code>、<code>comparator</code>三个属性字段。其中，<code>check</code>对应着要检查的字段，<code>expect</code>对应着检查字段预期的值，这两项是必须指定的；<code>comparator</code>字段对应着比较方法，若不指定，则默认采用<code>eq</code>，即检查字段与预期值相等。</p>
<p>为了实现尽可能强大的检查功能，<code>check</code>属性值可通过链式操作精确指定具体的字段，<code>comparator</code>也内置实现了大量的检查功能。</p>
<p>举个例子可能会更清晰些。假如某结构的响应结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// status code: 200</span><br><span class="line"></span><br><span class="line">// response headers</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// response body content</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"success"</span>: False,</span><br><span class="line">   <span class="attr">"person"</span>: &#123;</span><br><span class="line">       <span class="attr">"name"</span>: &#123;</span><br><span class="line">           <span class="attr">"first_name"</span>: <span class="string">"Leo"</span>,</span><br><span class="line">           <span class="attr">"last_name"</span>: <span class="string">"Lee"</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">"age"</span>: <span class="number">29</span>,</span><br><span class="line">       <span class="attr">"cities"</span>: [<span class="string">"Guangzhou"</span>, <span class="string">"Shenzhen"</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么假如我们要检查<code>status code</code>，<code>check</code>就可以指定为<code>status_code</code>；假如要检查<code>response headers</code>中的<code>Content-Type</code>，<code>check</code>就可以指定为<code>headers.content-type</code>；假如要检查<code>response body</code>中的<code>first_name</code>，<code>check</code>就可以指定为<code>content.person.name.first_name</code>。可以看出，假如下一层级为字典结构，那么就可以通过<code>.</code>运算符指定下一层级的<code>key</code>，依次类推。</p>
<p>对于字段内容为列表<code>list</code>的情况略有不同，我们需要通过序号来指定具体检查哪一项内容。例如，<code>Guangzhou</code>对应的检查项为<code>content.person.cities.0</code>，<code>Shenzhen</code>对应的检查项为<code>content.person.cities.1</code>。</p>
<p>在比较方式（<code>comparator</code>）方面，<code>HttpRunner</code>除了<code>eq</code>，还内置了大量的检查方法。例如，我们可以通过<code>gt</code>、<code>ge</code>、<code>lt</code>、<code>le</code>等比较数值大小，通过<code>len_eq</code>、<code>len_gt</code>、<code>len_lt</code>等比较长度是否相等（列表、字典、字符串均适用），通过<code>contains</code>、<code>contained_by</code>来判断包含关系，通过<code>startswith</code>、<code>endswith</code>判断字符串的开头结尾，甚至通过<code>regex_match</code>来判断是否满足正则匹配等。详细的比较方式还有许多，需要时可查看<a href="http://httprunner.readthedocs.io/en/latest/write-testcases.html#comparator" target="_blank" rel="noopener">comparator</a>表格。</p>
<h2 id="存在的局限性"><a href="#存在的局限性" class="headerlink" title="存在的局限性"></a>存在的局限性</h2><p>在大多数情况下，<code>HttpRunner</code>的结果校验器（validator）是够用的。不过问题在于，框架不可能为用户实现所有的检查方法，假如用户需要某些特殊的检查方法时，<code>HttpRunner</code>就没法实现了。</p>
<p>这的确是一个问题，之前<code>Junho2010</code>提的issue <a href="https://github.com/HttpRunner/HttpRunner/issues/29" target="_blank" rel="noopener">#29</a>中举了一个例子，应该也算是比较有代表性。</p>
<blockquote>
<p>发送请求时的数据使用了随机生成，然后需要比较结果中的数据是否是和这个相关（通过某个算法转换）。比如我输入的是321，我的结果是<code>(3+2+1) * avg(3+2+1)</code>这种转化，目前的comparator是比较难于实现的。</p>
</blockquote>
<p>要解决这个问题，最好的方式应该是在<code>HttpRunner</code>中实现自定义结果校验器的机制；用户在有需要的时候，可以自己编写校验函数，然后在<code>validate</code>中引用校验函数。之前也介绍过<code>HttpRunner</code>的热加载机制，<a href="https://debugtalk.com/post/apitestengine-hot-plugin/">《约定大于配置：ApiTestEngine实现热加载机制》</a>，自定义结果校验器应该也是可以采用这种方式来实现的。</p>
<p>第二个需要优化的点，<code>HttpRunner</code>的结果校验器还不支持变量引用，会造成某些场景下的局限性。例如，<code>testwangchao</code>曾提过一个issue <a href="https://github.com/HttpRunner/HttpRunner/issues/52" target="_blank" rel="noopener">#52</a>：</p>
<blockquote>
<p>接口response内，会返回数据库内的自增ID。ID校验的时候，希望<code>expected</code>为参数化的值。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">validate:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;"check":</span> <span class="string">"content.data.table_list.0.id"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="string">"$id"</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外，在<a href="https://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文中有介绍过，结果提取器（<code>extract</code>）新增实现了通过正则表达式对任意文本响应内容的字段提取。考虑到结果校验器（<code>validate</code>）也需要先从结果响应中提取出特定字段才能与预期值进行比较，在具体实现上完全可以复用同一部分代码，因此在<code>validate</code>的<code>check</code>部分也可以进行统一化处理。</p>
<p>经过前面的局限性问题描述，我们的改造目标也明确了，主要有三个方面：</p>
<ul>
<li>新增支持自定义结果校验器</li>
<li>结果校验器中实现变量引用</li>
<li>结果校验内容新增支持正则表达式提取</li>
</ul>
<h2 id="改造结果"><a href="#改造结果" class="headerlink" title="改造结果"></a>改造结果</h2><p>具体的改造过程就不写了，有兴趣的同学可以直接阅读源码，重点查看<a href="https://github.com/HttpRunner/HttpRunner/blob/master/httprunner/context.py" target="_blank" rel="noopener"><code>httprunner/context.py</code></a>中的<code>parse_validator</code>、<code>do_validation</code>和<code>validate</code>三个函数。</p>
<p>经过优化后，改造目标中的三项功能都实现了。为了更好地展现改造后的结果校验器，此处将结合实例进行演示。</p>
<h3 id="新增支持自定义结果校验器"><a href="#新增支持自定义结果校验器" class="headerlink" title="新增支持自定义结果校验器"></a>新增支持自定义结果校验器</h3><p>先来看第一个优化项，新增支持自定义结果校验器。</p>
<p>假设我们需要使用HTTP响应状态码各个数字的和来进行校验，例如，<code>201</code>状态码对应的数字和为3，<code>503</code>状态码对应的数字和为8。该实例只是为了演示用，实际上并不会用到这样的校验方式。</p>
<p>首先，该种校验方式在<code>HttpRunner</code>中并没有内置，因此需要我们自己来实现。实现方式与热加载机制相同，只需要将自定义的校验函数放置到当前<code>YAML/JSON</code>文件同级或者父级目录的<code>debugtalk.py</code>中。</p>
<p>对于自定义的校验函数，需要遵循三个规则：</p>
<ul>
<li>自定义校验函数需放置到<code>debugtalk.py</code>中</li>
<li>参数有两个：第一个为原始数据，第二个为原始数据经过运算后得到的预期结果值</li>
<li>在校验函数中通过<code>assert</code>将实际运算结果与预期结果值进行比较</li>
</ul>
<p>对于前面提到的演示案例，我们就可以在<code>debugtalk.py</code>中编写如下校验函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_status_code</span><span class="params">(status_code, expect_sum)</span>:</span></span><br><span class="line">    <span class="string">""" sum status code digits</span></span><br><span class="line"><span class="string">        e.g. 400 =&gt; 4, 201 =&gt; 3</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sum_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> str(status_code):</span><br><span class="line">        sum_value += int(digit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> sum_value == expect_sum</span><br></pre></td></tr></table></figure>

<p>然后，在<code>YAML/JSON</code>格式测试用例的<code>validate</code>中，我们就可以将校验函数名称<code>sum_status_code</code>作为<code>comparator</code>进行使用了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"sum_status_code"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="number">2</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>由此可见，自定义的校验函数<code>sum_status_code</code>与<code>HttpRunner</code>内置的校验方法<code>eq</code>在使用方式上完全相同，应该没有理解上的难度。</p>
<h3 id="结果校验器中实现变量引用"><a href="#结果校验器中实现变量引用" class="headerlink" title="结果校验器中实现变量引用"></a>结果校验器中实现变量引用</h3><p>对于第二个优化项，结果校验器中实现变量引用。在使用方式上我们应该与<code>request</code>中的变量引用一致，即通过<code>$var</code>的方式来引用变量<code>var</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - expect_status_code:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">        - token_len:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">    extract:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="string">"$expect_status_code"</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="string">"$token_len"</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"$token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="string">"$token_len"</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过以上示例可以看出，在结果校验器<code>validate</code>中，<code>check</code>和<code>expect</code>均可实现实现变量的引用；而引用的变量，可以来自四种类型：</p>
<ul>
<li>当前<code>test</code>中定义的<code>variables</code>，例如<code>expect_status_code</code></li>
<li>当前<code>test</code>中提取（<code>extract</code>）的结果变量，例如<code>token</code></li>
<li>当前测试用例集<code>testset</code>中，先前<code>test</code>中提取（<code>extract</code>）的结果变量</li>
<li>当前测试用例集<code>testset</code>中，全局配置<code>config</code>中定义的变量</li>
</ul>
<p>而<code>check</code>字段除了可以引用变量，以及保留了之前的链式操作定位字段（例如上例中的<code>content.token</code>）外，还新增了采用正则表达式提取内容的方式，也就是第三个优化项。</p>
<h3 id="结果校验内容新增支持正则表达式提取"><a href="#结果校验内容新增支持正则表达式提取" class="headerlink" title="结果校验内容新增支持正则表达式提取"></a>结果校验内容新增支持正则表达式提取</h3><p>假设如下接口的响应结果内容为<code>LB123abcRB789</code>，那么要提取出<code>abc</code>部分进行校验，就可以采用如下描述方式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"LB123(.*)RB789"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="string">"abc"</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可见在使用方式上与在结果提取器（<code>extract</code>）中完全相同。</p>
<h3 id="结果校验器的进一步简化"><a href="#结果校验器的进一步简化" class="headerlink" title="结果校验器的进一步简化"></a>结果校验器的进一步简化</h3><p>最后，为了进一步简化结果校验的描述，我在<code>validate</code>中新增实现了一种描述方式。</p>
<p>简化后的描述方式与原始方式对比如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">validate:</span></span><br><span class="line"><span class="attr">    - comparator_name:</span> <span class="string">[check_item,</span> <span class="string">expect_value]</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;"check":</span> <span class="string">check_item,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">comparator_name,</span> <span class="string">"expect"</span><span class="string">:</span> <span class="string">expect_value&#125;</span></span><br></pre></td></tr></table></figure>

<p>同样是前面的例子，采用新的描述方式后会更加简洁。而两种方式表达的含义是完全等价的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["status_code",</span> <span class="string">$expect_status_code]</span></span><br><span class="line"><span class="attr">        - sum_status_code:</span> <span class="string">["status_code",</span> <span class="number">2</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - len_eq:</span> <span class="string">["$token",</span> <span class="string">$token_len]</span></span><br><span class="line"><span class="attr">        - len_eq:</span> <span class="string">["content.token",</span> <span class="number">16</span><span class="string">]</span></span><br><span class="line"><span class="attr">        - eq:</span> <span class="string">["LB123(.*)RB789",</span> <span class="string">"abc"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>当然，此次优化保证了与历史版本的兼容，之前编写的测试用例脚本的运行是完全不会受到任何影响的。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/HttpRunner-supports-HAR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/HttpRunner-supports-HAR/" class="post-title-link" itemprop="url">HttpRunner 支持 HAR 意味着什么？</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-14T00:00:00+08:00">2017-11-14</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>HttpRunner</code>开始支持<code>HAR</code>啦！！！</p>
<p>如果你还没有体会到这三个感叹号的含义，那们你可能对<code>HAR</code>还不了解。</p>
<h2 id="HAR-是什么？"><a href="#HAR-是什么？" class="headerlink" title="HAR 是什么？"></a>HAR 是什么？</h2><p><code>HAR</code>的全称为<code>HTTP Archive</code>，是<a href="https://www.w3.org/" target="_blank" rel="noopener"><code>W3C(World Wide Web Consortium)</code></a>发布的一个通用标准。简单地说，<code>HAR</code>是一个约定的<code>JSON</code>文件格式，用于记录<code>HTTP</code>请求交互的所有内容，包括请求响应的详细记录和性能度量数据。</p>
<p>虽然当前<code>HAR</code>标准还处于<code>Draft</code>状态，但它已经被业界广泛地采用了，许多我们日常使用的工具都已支持<code>HAR</code>。在下面罗列的工具中，相信大家都已经比较熟悉了。</p>
<ul>
<li>Fiddler</li>
<li>Charles Web Proxy</li>
<li>Google Chrome</li>
<li>Firebug</li>
<li>HttpWatch</li>
<li>Firefox</li>
<li>Internet Explorer 9</li>
<li>Microsoft Edge</li>
<li>Paw</li>
<li>Restlet Client</li>
</ul>
<p>可以看出，工具覆盖了主流的抓包工具、浏览器和接口测试工具。这些工具都支持<code>HAR</code>标准，可以将录制得到的数据包导出为<code>.har</code>的文件。</p>
<p>假如我们可以将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例，这就相当于<code>HttpRunner</code>可以和非常多的工具结合使用，并获得了接口录制和用例生成功能，灵活性和易用性都将得到极大的提升。</p>
<p>那么，将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例是否可行呢？</p>
<p>我们不妨先研究下<code>HAR</code>的格式。</p>
<h2 id="HAR-格式详解"><a href="#HAR-格式详解" class="headerlink" title="HAR 格式详解"></a>HAR 格式详解</h2><p>通过如上列出的任意一款工具，都可以将录制得到的数据包导出为<code>.har</code>的文件。我们采用文本编辑器打开<code>.har</code>文件后，会发现是一个<code>JSON</code>的数据结构。</p>
<p>默认情况下，<code>.har</code>文件的<code>JSON</code>数据结构是经过压缩的，直接看可能不够直观。推荐大家可以在文本编辑器中安装<code>Prettify JSON</code>的插件，然后就可以将压缩后的<code>JSON</code>数据一键转换为美观的格式。</p>
<p>更好的方式是，我们可以直接查看<code>W3C</code>编写的<a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HAR/Overview.html" target="_blank" rel="noopener"><code>HAR</code>格式标准</a>。</p>
<p>通过文档可知，<code>HAR</code>是只有一个key的<code>JSON</code>数据结构，并且key值只能为<code>log</code>；而<code>log</code>的值也为一个<code>JSON</code>结构，里面的key包括：<code>version</code>、<code>creator</code>、<code>browser</code>、<code>pages</code>、<code>entries</code>、<code>comment</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"log"</span>: &#123;</span><br><span class="line">        <span class="attr">"version"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"creator"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"browser"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"pages"</span>: [],</span><br><span class="line">        <span class="attr">"entries"</span>: [],</span><br><span class="line">        <span class="attr">"comment"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>version</code>、<code>creator</code>和<code>entries</code>是必有字段，不管是哪款工具导出的<code>.har</code>文件，肯定都会包含这三个字段。而我们在转换生成自动化测试用例时，只需获取HTTP请求和响应的内容，这些全都包含在<code>entries</code>里面，因此我们只需要关注<code>entries</code>的内容即可。</p>
<p><code>entries</code>字段对应的值为一个列表型数据结构，里面的值按照请求时间进行排序，罗列出各个HTTP请求的详细内容。具体地，HTTP请求记录的信息如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"entries": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"pageref"</span>: <span class="string">"page_0"</span>,</span><br><span class="line">        <span class="attr">"startedDateTime"</span>: <span class="string">"2009-04-16T12:07:23.596Z"</span>,</span><br><span class="line">        <span class="attr">"time"</span>: <span class="number">50</span>,</span><br><span class="line">        "request": &#123;...&#125;,</span><br><span class="line">        "response": &#123;...&#125;,</span><br><span class="line">        "cache": &#123;...&#125;,</span><br><span class="line">        "timings": &#123;&#125;,</span><br><span class="line">        "serverIPAddress": "10.0.0.1",</span><br><span class="line">        "connection": "52492",</span><br><span class="line">        "comment": ""</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>由此可见，记录的HTTP信息非常全面，包含了HTTP请求交互过程中的所有内容。</p>
<p>而从生成自动化测试用例的角度来看，我们并不需要那么多信息，我们只需从中提取关键信息即可。</p>
<p>编写自动化测试用例，最关键的信息是要知道接口的请求URL、请求方法、请求headers、请求数据等，这些都包含在<code>request</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"request": &#123;</span><br><span class="line">    "method": "GET",</span><br><span class="line">    "url": "http://www.example.com/path/?param=value",</span><br><span class="line">    "httpVersion": "HTTP/1.1",</span><br><span class="line">    "cookies": [],</span><br><span class="line">    "headers": [],</span><br><span class="line">    "queryString" : [],</span><br><span class="line">    "postData" : &#123;&#125;,</span><br><span class="line">    "headersSize" : 150,</span><br><span class="line">    "bodySize" : 0,</span><br><span class="line">    "comment" : ""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这些信息，我们就可以完成HTTP请求的构造。</p>
<p>当请求发送出去后，我们要想实现自动化地判断接口响应是否正确，我们还需要设置一些断言。而与HTTP响应相关的所有信息全都包含在<code>response</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"response": &#123;</span><br><span class="line">    "status": 200,</span><br><span class="line">    "statusText": "OK",</span><br><span class="line">    "httpVersion": "HTTP/1.1",</span><br><span class="line">    "cookies": [],</span><br><span class="line">    "headers": [],</span><br><span class="line">    "content": &#123;&#125;,</span><br><span class="line">    "redirectURL": "",</span><br><span class="line">    "headersSize" : 160,</span><br><span class="line">    "bodySize" : 850,</span><br><span class="line">    "comment" : ""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从通用性的角度考虑，我们会判断HTTP响应的状态码是否正确，这对应着<code>status</code>字段；如果我们还想在接口业务层面具有更多的判断，我们还会判断响应内容中的一些关键字段是否符合预期，这对应着<code>content</code>字段。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"content": &#123;</span><br><span class="line">    "size": 33,</span><br><span class="line">    "compression": 0,</span><br><span class="line">    "mimeType": "text/html; charset=utf-8",</span><br><span class="line">    "text": "\n",</span><br><span class="line">    "comment": ""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>content</code>字段，可能会稍微复杂一些，因为接口响应内容的格式可能多种多样。</p>
<p>例如，响应内容可能<code>text/html</code>页面的形式，也可能是<code>application/json</code>的形式，具体类型可以查看<code>mimeType</code>得到，而具体的内容存储在<code>text</code>字段中。</p>
<p>另外，有时候响应数据还可能是经过编码的，用的最多的编码方式为<code>base64</code>。我们可以根据<code>encoding</code>字段获取得到具体的编码形式，然后采用对应的解码方式对<code>text</code>进行解码，最终获得原始的响应内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"content": &#123;</span><br><span class="line">    "size": 63,</span><br><span class="line">    "mimeType": "application/json; charset=utf-8",</span><br><span class="line">    "text": "eyJJc1N1Y2Nlc3MiOnRydWUsIkNvZGUiOjIwMCwiVmFsdWUiOnsiQmxuUmVzdWx0Ijp0cnVlfX0=",</span><br><span class="line">    "encoding": "base64"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>以上面的<code>content</code>为例，我们通过<code>encoding</code>查看到编码形式为<code>base64</code>，并通过<code>text</code>字段获取到编码后的内容；那么我们就可以采用<code>base64</code>的解码函数，转换得到原始的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(text)</span><br><span class="line">b<span class="string">'&#123;"IsSuccess":true,"Code":200,"Value":&#123;"BlnResult":true&#125;&#125;'</span></span><br></pre></td></tr></table></figure>

<p>同时，我们根据<code>mimeType</code>可以得到响应内容<code>application/json</code>数据类型，那么就可以对其再进行<code>json.loads</code>操作，最终得到可供程序处理的<code>JSON</code>数据结构。</p>
<p>通过上述对<code>HAR</code>格式的详细介绍，可以看出<code>HAR</code>格式十分清晰，在对其充分了解的基础上，再编写测试用例转换工具就很简单了。</p>
<h2 id="har2case"><a href="#har2case" class="headerlink" title="har2case"></a>har2case</h2><p>编码过程没有太多值得说的，直接看最终成品吧。</p>
<p>最终产出的工具就是<a href="https://github.com/HttpRunner/har2case" target="_blank" rel="noopener"><code>har2case</code></a>，是一个命令行工具，可以直接将<code>.har</code>文件转换为<code>YAML</code>或<code>JSON</code>格式的自动化测试用例。</p>
<p>当前<code>har2case</code>已经上传到<code>PYPI</code>上了，通过<code>pip</code>或<code>easy_install</code>即可安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install har2case</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ easy_install har2case</span><br></pre></td></tr></table></figure>

<p>使用方式很简单，只需在<code>har2case</code>命令后分别带上<code>HAR</code>源文件路径和目标生成的<code>YAML/JSON</code>路径即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ har2case tests/data/demo.har demo.yml</span><br><span class="line">INFO:root:Generate YAML testset successfully: demo.yml</span><br><span class="line"></span><br><span class="line">$ har2case tests/data/demo.har demo.json</span><br><span class="line">INFO:root:Generate JSON testset successfully: demo.json</span><br></pre></td></tr></table></figure>

<p>可以看出，具体是生成<code>YAML</code>还是<code>JSON</code>格式的问题，取决于指定目标文件的后缀：后缀为<code>.yml</code>或<code>.yaml</code>则生成<code>YAML</code>文件，后缀为<code>.json</code>则生成<code>JSON</code>文件。</p>
<p>如果不指定目标文件也行，则会默认生成<code>JSON</code>文件，文件名称和路径与<code>.har</code>源文件相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ har2case tests/data/demo.har</span><br><span class="line">INFO:root:Generate JSON testset successfully: tests/data/demo.json</span><br></pre></td></tr></table></figure>

<p>具体的使用方式可以通过执行<code>har2case -h</code>查看。</p>
<p>在大多数情况下，生成的用例可直接在<code>HttpRunner</code>中使用，当然，是做接口自动化测试、接口性能测试，还是持续集成线上监控，这都取决于你。</p>
<p>不过，假如录制的场景中包含动态关联的情况，即后续接口请求参数依赖于前面接口的响应，并且每次调用接口时参数都会动态变化，那么就需要人工再对生成的脚本进行关联处理，甚至包括编写一些自定义函数等。</p>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>读到这里，相信大家应该能体会到文章开头那三个感叹号的含义了，我也的确是带着难以言表的兴奋之情发布这个新功能的。</p>
<p>经过小范围的实际使用，效果很是不错，接口自动化测试用例的编写效率得到了极大的提升。而且，由于<code>HAR</code>本身的开放性，留给用户的选择非常多。</p>
<p>即便如此，我觉得<code>HttpRunner</code>的易用性还可以得到更大的提升。</p>
<p>当前，我规划了两项新特性将在近期完成：</p>
<ul>
<li>支持<code>PostMan</code>：将<code>Postman Collection Format</code>格式转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例；</li>
<li>支持<code>Swagger</code>：将<code>Swagger</code>定义的API转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例。</li>
</ul>
<p>等这两个新特性完成之后，相信<code>HttpRunner</code>会更上一个台阶。</p>
<p>如果你们有什么更好的想法，欢迎联系我。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/ApiTestEngine-rename-to-HttpRunner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/ApiTestEngine-rename-to-HttpRunner/" class="post-title-link" itemprop="url">ApiTestEngine 正式更名为 HttpRunner</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-08 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-08T00:00:00+08:00">2017-11-08</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文的末尾，我提到随着<code>ApiTestEngine</code>的发展，它的实际功能特性和名字已经不大匹配，需要考虑改名了。</p>
<p>经过慎重考虑，最终决定将<code>ApiTestEngine</code>正式更名为<code>HttpRunner</code>。</p>
<h2 id="名字的由来"><a href="#名字的由来" class="headerlink" title="名字的由来"></a>名字的由来</h2><p>为什么选择<code>HttpRunner</code>这个名字呢？</p>
<p>在改名之前，我的想法很明确，就是要在新名字中体现该工具最核心的两个特点：</p>
<ul>
<li>该工具可实现任意基于HTTP协议接口的测试（自动化测试、持续集成、线上监控都是以此作为基础）</li>
<li>该工具可同时实现性能测试（这是区别于其它工具的最大卖点）</li>
</ul>
<p>围绕着这两点，我开始踏上了纠结的取名之路。</p>
<p>首先想到的，<code>ApiTestEngine</code>实现<code>HTTP</code>请求是依赖于<a href="http://python-requests.org" target="_blank" rel="noopener"><code>Python Requests</code></a>，实现性能测试是依赖于<a href="http://locust.io" target="_blank" rel="noopener"><code>Locust</code></a>，而<code>Locust</code>同样依赖于<code>Python Requests</code>。可以说，<code>ApiTestEngine</code>完全是构建在<code>Python Requests</code>之上的，后续无论怎么进化，这一层关系应该都不会变。</p>
<p>考虑到<code>Python Requests</code>的<code>slogan</code>是：</p>
<blockquote>
<p>Python HTTP Requests for Humans™</p>
</blockquote>
<p>因此，我想在<code>ApiTestEngine</code>的新名字中应该包含<code>HTTP</code>。</p>
<p>那如何体现性能测试呢？</p>
<p>想到的关键词就<code>load</code>、<code>perf</code>、<code>meter</code>这些（来源于LoadRunner，NeoLoad，JMeter），但又不能直接用，因为名字中带有这些词让人感觉就只是性能测试工具。而且，还要考虑跟<code>HTTP</code>这个词进行搭配。</p>
<p>最终，感觉<code>runner</code>这个词比较合适，一方面这来源于<code>LoadRunner</code>，大众的认可度可能会比较高；同时，这个词用在自动化测试和性能测试上都不会太牵强。</p>
<p>更重要的是，<code>HttpRunner</code>这个组合词当前还没有人用过，不管是<code>PyPI</code>还是<code>GitHub</code>，甚至域名都是可注册状态。</p>
<p>所以，就认定<code>HttpRunner</code>这个名字了。</p>
<h2 id="相关影响"><a href="#相关影响" class="headerlink" title="相关影响"></a>相关影响</h2><p><code>ApiTestEngine</code>更名为<code>HttpRunner</code>之后，会对用户产生哪些影响呢？</p>
<p>先说结论，没有任何不好的影响！</p>
<p>在链接访问方面，受益于GitHub仓库链接的自动重定向机制，仓库在改名或者过户（Transfer ownership）之后，访问原有链接会自动实现重定向，因此之前博客中的链接也都不会受到影响。</p>
<p>新的仓库地址：<a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="noopener">https://github.com/HttpRunner/HttpRunner</a></p>
<p>在使用的命令方面，<code>HttpRunner</code>采用<code>httprunner</code>作为新的命令代替原有的<code>ate</code>命令；当然，为了考虑兼容性，<code>HttpRunner</code>对<code>ate</code>命令也进行了保留，因此<code>httprunner</code>和<code>ate</code>命令同时可用，并完全等价。在性能测试方面，<code>locusts</code>命令保持不变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ httprunner -V</span><br><span class="line">HttpRunner version: 0.8.1b</span><br><span class="line">PyUnitReport version: 0.1.3b</span><br></pre></td></tr></table></figure>

<p>既然是全新的名字，新的篇章必然也得有一些新的东西。</p>
<p>为了方面用户安装，<code>HttpRunner</code>已托管至<a href="https://pypi.python.org/pypi/HttpRunner" target="_blank" rel="noopener"><code>PyPI</code></a>；后续大家可以方便的采用<code>pip</code>命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install HttpRunner</span><br></pre></td></tr></table></figure>

<p>同时，<code>HttpRunner</code>新增了大量使用说明文档（之前的博客主要都是开发过程记录），并托管到专业的<code>readthedocs</code>上面。在文档语言方面，英文优先，中文相对滞后。</p>
<p>访问网址：</p>
<ul>
<li>英文：<a href="http://httprunner.readthedocs.io/" target="_blank" rel="noopener">http://httprunner.readthedocs.io/</a></li>
<li>中文（滞后）：<a href="http://httprunner-cn.readthedocs.io/" target="_blank" rel="noopener">http://httprunner-cn.readthedocs.io/</a></li>
</ul>
<p>另外，为了具有更高的逼格，同时购入域名<code>httprunner.top</code>，后续将作为项目的主页地址。当前还处于实名认证中，预计2~3个工作日后就可以访问了。</p>
<p>关于项目改名这事儿，就说到这儿吧，希望你们也喜欢。</p>
<blockquote>
<p>Hello World, HttpRunner.</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/apitestengine-not-only-about-json-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/apitestengine-not-only-about-json-api/" class="post-title-link" itemprop="url">ApiTestEngine，不再局限于 API 的测试</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-06 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-06T00:00:00+08:00">2017-11-06</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从编写<a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>至今，已经快半年了。在这一段时间内，<code>ApiTestEngine</code>经过持续迭代，也已完全实现了当初预设的目标。</p>
<p>然而，在设计<code>ApiTestEngine</code>之初只考虑了面向最常规的API接口类型，即<code>HTTP</code>响应内容为<code>JSON</code>数据结构的类型。那么，如果<code>HTTP</code>接口响应内容不是<code>JSON</code>，而是<code>XML</code>或<code>SOAP</code>，甚至为<code>HTML</code>呢？</p>
<p>答案是，不支持！</p>
<p>不支持的原因是什么呢？</p>
<p>其实，不管是何种业务类型或者技术架构的系统接口，我们在对其进行测试时都可以拆分为三步：</p>
<ul>
<li>发起接口请求（Request）</li>
<li>解析接口响应（Parse Response）</li>
<li>校验测试结果（Validation）</li>
</ul>
<p>而<code>ApiTestEngine</code>不支持<code>XML/HTML</code>类型的接口，问题恰恰是出现在<code>解析接口响应</code>和<code>校验测试结果</code>这两个环节。考虑到<code>校验测试结果</code>环节是依赖于<code>解析接口响应</code>，即需要先从接口响应结果中解析出具体的字段，才能实现与预期结果的校验检测，因此，制约<code>ApiTestEngine</code>无法支持<code>XML/HTML</code>类型接口的根本原因在于无法支持对<code>XML/HTML</code>的解析。</p>
<p>也因为这个原因，<code>ApiTestEngine</code>存在局限性，没法推广到公司内部的所有项目组。遇到<code>JSON</code>类型以外的接口时，只能再使用别的测试工具，体验上很是不爽。</p>
<p>在经历了一段时间的不爽后，我开始重新思考<code>ApiTestEngine</code>的设计，希望使其具有更大的适用范围。通过前面的分析我们也不难看出，解决问题的关键在于实现针对<code>XML/HTML</code>的解析器。</p>
<h2 id="JSON接口的解析"><a href="#JSON接口的解析" class="headerlink" title="JSON接口的解析"></a>JSON接口的解析</h2><p>在实现<code>XML/HTML</code>的解析器之前，我们不妨先看下<code>ApiTestEngine</code>的<code>JSON</code>解析器是怎么工作的。</p>
<p>在<code>JSON</code>类型的数据结构中，无论结构有多么复杂，数据字段都只可能为如下三种数据类型之一：</p>
<ul>
<li>值（value）类型，包括数字、字符串等；该种数据类型的特点是不会再有下一层极的数据；</li>
<li>字典（dict）类型；该种数据类型的特点是包含无序的下一层极的数据；</li>
<li>列表（list）类型：该种数据类型的特点是包含有序的下一层极的数据。</li>
</ul>
<p>基于这一背景，<code>ApiTestEngine</code>在实现<code>JSON</code>的字段提取器（<code>extractor</code>）时，就采用了点（<code>.</code>）的运算符。</p>
<p>例如，假如<code>HTTP</code>接口响应的<code>headers</code>和<code>body</code>为如下内容：</p>
<p>response headers:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    <span class="attr">"Content-Length"</span>: <span class="number">69</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>response body:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"success"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"person"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"first_name"</span>: <span class="string">"Leo"</span>,</span><br><span class="line">            <span class="attr">"last_name"</span>: <span class="string">"Lee"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">29</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: [<span class="string">"Guangzhou"</span>, <span class="string">"Shenzhen"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么对应的字段提取方式就为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;headers.content-type&quot; =&gt; &quot;application/json&quot;</span><br><span class="line">&quot;headers.content-length&quot; =&gt; 69</span><br><span class="line">&quot;body.success&quot;/&quot;content.success&quot;/&quot;text.success&quot; =&gt; false</span><br><span class="line"></span><br><span class="line">&quot;content.person.name.first_name&quot; =&gt; &quot;Leo&quot;</span><br><span class="line">&quot;content.person.age&quot; =&gt; 29</span><br><span class="line">&quot;content.person.cities&quot; =&gt; [&quot;Guangzhou&quot;, &quot;Shenzhen&quot;]</span><br><span class="line">&quot;content.person.cities.0&quot; =&gt; &quot;Guangzhou&quot;</span><br><span class="line">&quot;content.person.cities.1&quot; =&gt; &quot;Shenzhen&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出，通过点（<code>.</code>）运算符，我们可以从上往下逐级定位到具体的字段：</p>
<ul>
<li>当下一级为字典时，通过<code>.key</code>来指定下一级的节点，例如<code>.person</code>，指定了<code>content</code>下的<code>person</code>节点；</li>
<li>当下一级为列表时，通过<code>.index</code>来指定下一级的节点，例如<code>.0</code>，指定了<code>cities</code>下的第一个元素。</li>
</ul>
<p>定位到具体字段后，我们也就可以方便地提取字段值供后续使用了，作为参数或者进行结果校验均可。</p>
<h2 id="实现XML-HTML的解析器"><a href="#实现XML-HTML的解析器" class="headerlink" title="实现XML/HTML的解析器"></a>实现XML/HTML的解析器</h2><p>从点（<code>.</code>）运算符的描述形式上来看，它和<code>XML/HTML</code>的<code>xpath</code>十分类似。既然如此，那我们针对<code>XML/HTML</code>类型的接口，是否可以基于<code>xpath</code>来实现解析器呢？</p>
<p>在大多数情况下的确可以。例如，针对如下HTML页面，当我们要获取标题信息时，我们就可以通过<code>xpath</code>来指定提取字段：<code>body/h1</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>订单页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>订单号：SA89193<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，如果我们想获取订单号（SA89193）时，使用<code>xpath</code>就没有办法了（通过<code>body/div/p</code>获取到的是<code>订单号：SA89193</code>，还需进一步地进行处理）。</p>
<p>那除了<code>xpath</code>，我们还能使用什么其它方法从<code>XML/HTML</code>中提取特定字段呢？</p>
<p>由于早些年对<code>LoadRunner</code>比较熟悉，因此我首先想到了<code>LoadRunner</code>的<code>web_reg_save_param</code>函数；在该函数中，我们可以通过指定左右边界（LB &amp; RB）来查找字段，将其提取出来并保存到变量中供后续使用。借鉴这种方式虽然可行，但在描述方式上还是比较复杂，特别是在<code>YAML</code>测试用例的<code>extract</code>中描述的时候。</p>
<p>再一想，这种方式的底层实现不就是正则表达式么。而且我们通过Python脚本解析网页时，采用正则表达式来对目标字段进行匹配和提取，的确也是通用性非常强的方式。</p>
<p>例如，假设我们现在想从<code>https://debugtalk.com</code>首页中提取出座右铭，通过查看网页源代码，我们可以看到座右铭对应的位置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"blog-motto"</span>&gt;</span>探索一个软件工程师的无限可能<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，要提取“探索一个软件工程师的无限可能”字符串时，我们就可以使用正则表达式<code>r&quot;blog-motto\&quot;&gt;(.*)&lt;/h2&gt;&quot;</code>进行匹配，然后使用<code>regex</code>的<code>group</code>将匹配内容提取出来。</p>
<p>对应的Python脚本实现如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re, requests</span><br><span class="line">&gt;&gt;&gt; resp = requests.get(<span class="string">"https://debugtalk.com"</span>)</span><br><span class="line">&gt;&gt;&gt; content = resp.text</span><br><span class="line">&gt;&gt;&gt; matched = re.search(r<span class="string">"blog-motto\"&gt;(.*)&lt;/h2&gt;"</span>, content)</span><br><span class="line">&gt;&gt;&gt; matched.group(1)</span><br><span class="line"><span class="string">'探索一个软件工程师的无限可能'</span></span><br></pre></td></tr></table></figure>

<p>思路确定后，实现起来就很快了。</p>
<p>此处省略256字。。。</p>
<p>最终，我在<code>ApiTestEngine</code>中新增实现了一个基于正则表达式的提取器。使用形式与JSON解析保持一致，只需要将之前的点（<code>.</code>）运算符更改为正则表达式即可。</p>
<p>还是前面提取座右铭的例子，我们就可以通过<code>YAML</code>格式来编写测试用例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">https://debugtalk.com/</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">    extract:</span></span><br><span class="line"><span class="attr">        - motto:</span> <span class="string">'blog-motto\"&gt;(.*)&lt;/h2&gt;'</span></span><br><span class="line"><span class="attr">    validate:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>需要说明的是，指定的正则表达式必须满足<code>r&quot;.*\(.*\).*&quot;</code>的格式要求，必须并且只能有一个分组（即一对括号）。如果在同一段内容中需要提取多个字段，那就分多次匹配即可。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>实现了基于正则表达式的提取器后，我们就彻底实现了对任意格式<code>HTTP</code>响应内容的解析，不仅限于<code>XML/HTML</code>类型，对于任意基于<code>HTTP</code>协议的的接口，<code>ApiTestEngine</code>都可以适用了。当然，如果接口响应是<code>JSON</code>类型，我们虽然可以也使用正则表达式提取，但更建议采用原有的点（<code>.</code>）运算符形式，因为描述更清晰。</p>
<p>至此，<code>ApiTestEngine</code>可以说是真正意义上实现了，面向任意类型的<code>HTTP</code>协议接口，只需要编写维护一份<code>YAML</code>用例，即可同时实现接口自动化测试、性能测试、持续集成、线上监控的全测试类型覆盖！</p>
<p>现在看来，<code>ApiTestEngine</code>的名字与其实际功能有些不大匹配了，是该考虑改名了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/apitestengine-hot-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/apitestengine-hot-plugin/" class="post-title-link" itemprop="url">约定大于配置：ApiTestEngine实现热加载机制</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-09T00:00:00+08:00">2017-09-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>中编写测试用例时，我们有时需要定义全局的变量，或者引用外部函数实现一些动态的计算逻辑。当前采用的方式是：</p>
<ul>
<li>若需定义全局的参数变量，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>variables</code>定义变量；</li>
<li>若需引用外部函数，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>import_module_items</code>导入指定的<code>Python</code>模块。</li>
</ul>
<p>虽然这种方式提供了极大的灵活性，但是对于用户来说可能会显得比较复杂。另外一方面，这种方式也会造成大量重复的情况。</p>
<p>例如，对于变量来说，假如我们的项目中存在100个测试场景，而每个场景中都需要将用户账号（<code>test@ijd</code>）作为全局变量来使用，那么在现有模式下，我们只能在这100个<code>YAML/JSON</code>文件的<code>config</code>中都采用如下方式定义一遍：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - username:</span> <span class="string">test@ijd</span></span><br></pre></td></tr></table></figure>

<p>同样的，对于外部函数来说，假如我们项目的100个测试场景都需要用到生成随机字符串的函数（<code>gen_random_string</code>），那么我们也不得不在这100个<code>YAML/JSON</code>文件的<code>config</code>中都导入一次该函数所在的<code>Python</code>模块（假设相对于工作目录的路径为<code>extra/utils.py</code>）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></span><br><span class="line"><span class="attr">    import_module_items:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">extra.utils</span></span><br></pre></td></tr></table></figure>

<p>由此可见，当测试场景越来越多以后，要维护好全局变量和外部函数，必定会是一个很大的工作量。</p>
<p>那么，如果既要能引用公共的变量和函数，又要减少重复的定义和导入，那要怎么做呢？</p>
<h2 id="pytest-的-conftest-py"><a href="#pytest-的-conftest-py" class="headerlink" title="pytest 的 conftest.py"></a>pytest 的 conftest.py</h2><p>前段时间在接触<code>pytest</code>时，看到<code>pytest</code>支持<code>conftest.py</code>的插件机制，这是一种在测试文件中可以实现模块自动发现和热加载的机制。具体地，只要是在文件目录存在命名为<code>conftest.py</code>的文件，里面定义的<code>hook</code>函数都会在<code>pytest</code>运行过程中被导入，并可被测试用例进行调用。同时，<code>conftest.py</code>存在优先级策略，从测试用例所在目录到系统根目录的整个路径中，越靠近测试用例的<code>conftest.py</code>优先级越高。</p>
<p>其实这也是采用了<code>约定大于配置</code>（<code>convention over configuration</code>）的思想。<code>约定大于配置</code>是一种软件设计范式，旨在减少软件开发人员需做决定的数量，在遵从约定的过程中就不自觉地沿用了最佳工程实践。我个人也是比较喜欢这种方式的，所以在设计<code>ApiTestEngine</code>的时候，也借鉴了一些类似的思想。</p>
<p>受到该启发，我想也可以采用类似的思想，采用自动热加载的机制，解决背景描述中存在的重复定义和引用的问题。</p>
<p>既然是<code>约定大于配置</code>，那么我们首先就得定一个默认的<code>Python</code>模块名，类似于<code>pytest</code>的<code>conftest.py</code>。</p>
<p>这就是<code>debugtalk.py</code>。</p>
<h2 id="debugtalk-py-的命名由来"><a href="#debugtalk-py-的命名由来" class="headerlink" title="debugtalk.py 的命名由来"></a>debugtalk.py 的命名由来</h2><p>为啥会采用<code>debugtalk.py</code>这个命名呢？</p>
<p>其实当时在想这个名字的时候也是耗费了很多心思，毕竟是要遵从<code>约定大于配置</code>的思想，因此在设计这个约定的命名时就格外谨慎，但始终没有想到一个既合适又满意的。</p>
<p>在我看来，这个命名应该至少满足如下两个条件：</p>
<ul>
<li>唯一性强</li>
<li>简单易记</li>
</ul>
<p>首先，约定的模块名应该具有较强的唯一性和较高的区分度，是用户通常都不会采用的命名；否则，可能就会出现测试用例在运行过程中，热加载时导入预期之外的<code>Python</code>模块。</p>
<p>但也不能仅仅为了具有区分度，就使用一个很长或者毫无意义的字符串作为模块名；毕竟还是要给用户使用的，总不能每次写用例时还要去查看下文档吧；所以命名简单易记便于用户使用也很重要。</p>
<p>也是因为这两个有点互相矛盾的原则，让我在设计命名时很是纠结。最终在拉同事讨论良久而无果的时候，同事说，不如就命名为<code>debugtalk.py</code>得了。</p>
<p>仔细一想，这命名还真符合要求。在唯一性方面，采用<code>debugtalk.py</code>在<code>Google</code>、<code>Bing</code>、<code>Baidu</code>等搜索引擎中采用精确匹配，基本没有无关信息，这样在后续遇到问题时，也容易搜索到已有的解决方案；而在简单易记方面，相信这个命名也不会太复杂。</p>
<p>当然，<code>debugtalk.py</code>只是作为框架默认加载的<code>Python</code>模块名，如果你不喜欢，也可以进行配置修改。</p>
<h2 id="热加载机制实现原理"><a href="#热加载机制实现原理" class="headerlink" title="热加载机制实现原理"></a>热加载机制实现原理</h2><p>然后，再来讲解下热加载机制的实现。</p>
<p>其实原理也不复杂，从背景描述可以看出，我们期望实现的需求主要有两点：</p>
<ul>
<li>自动发现<code>debugtalk.py</code>函数模块，并且具有优先级策略；</li>
<li>将<code>debugtalk.py</code>函数模块中的变量和函数导入到当前框架运行的内存空间。</li>
</ul>
<p>将这两点与测试用例引擎的实现机制结合起来，<code>ApiTestEngine</code>在运行过程中的热加载机制应该就如下图所示。</p>
<p><img src="/images/ate-hot-plugin.png" alt></p>
<p>这个流程图对热加载机制描述得已经足够清晰了，我再针对其中的几个点进行说明：</p>
<p>1、在初始化测试用例集（testset）的时候，除了将<code>config</code>中<code>variables</code>和<code>import_module_items</code>指定的变量和函数导入外，还会默认导入<code>ate/built_in.py</code>模块。之所以这么做，是因为对于大多数系统可能都会用到一些通用的函数，例如获取当前时间戳（<code>get_timestamp</code>）、生成随机字符串（<code>gen_random_string</code>）等。与其在每个项目中都单独去实现这些函数，不如就将其添加到框架中作为默认支持的函数（相当于框架层面的<code>debugtalk.py</code>），这样大家在项目中就不需要再重复做这些基础性工作了。</p>
<p>2、在<code>ApiTestEngine</code>框架中，存在测试用例（<code>testcase</code>）和测试用例集（<code>testset</code>）两个层面的作用域，两者的界限十分明确。这样设计的目的在于，我们既可以实现用例集层面的变量和函数的定义和导入，也可以保障各个用例之间的独立性，不至于出现作用域相互污染的情况。具体地，作用域在用例集初始化时定义或导入的变量和函数，会存储在用例集层面的作用域；而在运行每条测试用例时，会先继承（<code>deepcopy</code>）用例集层面的作用域，如果存在同名的变量或函数定义，则会对用例集层面的变量和函数进行覆盖，同时用例集层面的变量和函数也并不会被修改。</p>
<p>3、从热加载的顺序可以看出，查找变量或函数的顺序是从测试用例所在目录开始，沿着父路径逐层往上，直到系统的根目录。因此，我们可以利用这个优先级原则来组织我们的用例和依赖的<code>Python</code>函数模块。例如，我们可以将不同模块的测试用例集文件放在不同的文件夹下：针对各个模块独有的依赖函数和变量，可以放置在对应文件夹的<code>debugtalk.py</code>文件中；而整个项目公共的函数和变量，就可以放置到项目文件夹的<code>debugtalk.py</code>中。</p>
<p>文件组织结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  project ✗ tree .</span><br><span class="line">.</span><br><span class="line">├── debugtalk.py</span><br><span class="line">├── module_A</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── debugtalk.py</span><br><span class="line">│   ├── testsetA1.yml</span><br><span class="line">│   └── testsetA2.yml</span><br><span class="line">└── module_B</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── debugtalk.py</span><br><span class="line">    ├── testsetB1.yml</span><br><span class="line">    └── testsetB2.yml</span><br></pre></td></tr></table></figure>

<p>这其中还有一点需要格外注意。因为我们在框架运行过程中需要将<code>debugtalk.py</code>作为函数模块进行导入，因此我们首先要保障<code>debugtalk.py</code>满足<code>Python</code>模块的要求，也就是在对应的文件夹中要包含<code>__init__.py</code>文件。</p>
<p>如果对热加载机制的实现感兴趣，可直接阅读框架源码，重点只需查看<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/ate/utils.py" target="_blank" rel="noopener"><code>ate/utils.py</code></a>中的三个函数：</p>
<ul>
<li>search_conf_item(start_path, item_type, item_name)</li>
<li>get_imported_module_from_file(file_path)</li>
<li>filter_module(module, filter_type)</li>
</ul>
<h2 id="测试用例编写方式的变化"><a href="#测试用例编写方式的变化" class="headerlink" title="测试用例编写方式的变化"></a>测试用例编写方式的变化</h2><p>在新增<code>热加载机制</code>之后，编写测试用例的方式发生一些改变（优化），主要包括三点：</p>
<ul>
<li>导入<code>Python</code>模块的关键词改名为<code>import_module_items</code>（原名为<code>import_module_functions</code>）；</li>
<li>不再需要显式指定导入的<code>Python</code>模块路径，变更为热加载机制自动发现；</li>
<li><code>Python</code>模块中的变量也会被导入，公共变量可放置在<code>Python</code>模块中，而不再必须通过<code>variables</code>定义。</li>
</ul>
<p>考虑到兼容性问题，框架升级的同时也保留了对原有测试用例编写方式的支持，因此框架升级对已有测试用例的正常运行也不会造成影响。不过，我还是强烈建议大家采用最新的用例编写方式，充分利用热加载机制带来的便利。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>现在回过头来看<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>的演进历程，以及之前写的关于<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>设计方面的文章，会发现当初的确是有一些考虑不周全的地方。也许这也是编程的乐趣所在吧，在前行的道路中，总会有新的感悟和新的收获，迭代优化的过程，就仿佛是在打磨一件艺术品。</p>
<p>这种感觉，甚好！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/apitestengine-supersede-locust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/apitestengine-supersede-locust/" class="post-title-link" itemprop="url">ApiTestEngine 集成 Locust 实现更好的性能测试体验</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-27T00:00:00+08:00">2017-08-27</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>不是接口测试框架么，也能实现性能测试？</p>
<p>是的，你没有看错，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>集成了<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>性能测试框架，只需一份测试用例，就能同时实现接口自动化测试和接口性能测试，在不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>任何特性的情况下，甚至比<code>Locust</code>本身更易用。</p>
<p>如果你还没有接触过<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>这款性能测试工具，那么这篇文章可能不适合你。但我还是强烈推荐你了解一下这款工具。简单地说，<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>是一款采用<code>Python</code>语言编写实现的开源性能测试工具，简洁、轻量、高效，并发机制基于<code>gevent</code>协程，可以实现单机模拟生成较高的并发压力。关于<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的特性介绍和使用教程，我之前已经写过不少，你们可以在我的博客中找到<a href="https://debugtalk.com/tags/Locust/">对应文章</a>。</p>
<p>如果你对实现的过程没有兴趣，可以直接跳转到文章底部，看<code>最终实现效果</code>章节。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>在当前市面上的测试工具中，接口测试和性能测试基本上是两个泾渭分明的领域。这也意味着，针对同一个系统的服务端接口，我们要对其实现接口自动化测试和接口性能测试时，通常都是采用不同的工具，分别维护两份测试脚本或用例。</p>
<p>之前我也是这么做的。但是在做了一段时间后我就在想，不管是接口功能测试，还是接口性能测试，核心都是要模拟对接口发起请求，然后对接口响应内容进行解析和校验；唯一的差异在于，接口性能测试存在并发的概念，相当于模拟了大量用户同时在做接口测试。</p>
<p>既然如此，那接口自动化测试用例和接口性能测试脚本理应可以合并为一套，这样就可以避免重复的脚本开发工作了。</p>
<p>在开发<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>的过程中，之前的文章也说过，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>完全基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>库实现HTTP的请求处理，可以在编写接口测试用例时复用到<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>的所有功能特性。而之前在学习<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码时，发现<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>在实现HTTP请求的时候，也完全是基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Python-Requests</code></a>库。</p>
<p>在这一层关系的基础上，我提出一个大胆的设想，能否通过一些方式或手段，可以使<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>中编写的<code>YAML/JSON</code>格式的接口测试用例，也能直接让<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>直接调用呢？</p>
<h2 id="灵感初探"><a href="#灵感初探" class="headerlink" title="灵感初探"></a>灵感初探</h2><p>想法有了以后，就开始探索实现的方法了。</p>
<p>首先，我们可以看下<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的脚本形式。如下例子是一个比较简单的场景（截取自官网首页）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.post(<span class="string">"/login"</span>, &#123;</span><br><span class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</span><br><span class="line">            <span class="string">"password"</span>: <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/about/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line">    task_set = WebsiteTasks</span><br><span class="line">    min_wait = <span class="number">5000</span></span><br><span class="line">    max_wait = <span class="number">15000</span></span><br></pre></td></tr></table></figure>

<p>在<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的脚本中，我们会在<code>TaskSet</code>子类中描述单个用户的行为，每一个带有<code>@task</code>装饰器的方法都对应着一个HTTP请求场景。而<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的一个很大特点就是，所有的测试用例脚本都是<code>Python</code>文件，因此我们可以采用Python实现各种复杂的场景。</p>
<p>等等！模拟单个用户请求，而且还是纯粹的Python语言，我们不是在接口测试中已经实现的功能么？</p>
<p>例如，下面的代码就是从单元测试中截取的测试用例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_testset</span><span class="params">(self)</span>:</span></span><br><span class="line">    testcase_file_path = os.path.join(</span><br><span class="line">        os.getcwd(), <span class="string">'examples/quickstart-demo-rev-3.yml'</span>)</span><br><span class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</span><br><span class="line">    results = self.test_runner.run_testset(testsets[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><code>test_runner.run_testset</code>是已经在<code>ApiTestEngine</code>中实现的方法，作用是传入测试用例（<code>YAML/JSON</code>）的路径，然后就可以加载测试用例，运行整个测试场景。并且，由于我们在测试用例<code>YAML/JSON</code>中已经描述了<code>validators</code>，即接口的校验部分，因此我们也无需再对接口响应结果进行校验描述了。</p>
<p>接下来，实现方式就非常简单了。</p>
<p>我们只需要制作一个<code>locustfile.py</code>的模板文件，内容如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> zmq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"><span class="keyword">from</span> ate <span class="keyword">import</span> utils, runner</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageTasks</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.test_runner = runner.Runner(self.client)</span><br><span class="line">        self.testset = self.locust.testset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_specified_scenario</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.test_runner.run_testset(self.testset)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line">    host = <span class="string">''</span></span><br><span class="line">    task_set = WebPageTasks</span><br><span class="line">    min_wait = <span class="number">1000</span></span><br><span class="line">    max_wait = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">    testcase_file_path = os.path.join(os.getcwd(), <span class="string">'skypixel.yml'</span>)</span><br><span class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</span><br><span class="line">    testset = testsets[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>可以看出，整个文件中，只有测试用例文件的路径是与具体测试场景相关的，其它内容全都可以不变。</p>
<p>于是，针对不同的测试场景，我们只需要将<code>testcase_file_path</code>替换为接口测试用例文件的路径，即可实现对应场景的接口性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ApiTestEngine git:(master) ✗ locust -f locustfile.py</span><br><span class="line">[2017-08-27 11:30:01,829] bogon/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-27 11:30:01,831] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>

<p>后面的操作就完全是<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的内容了，使用方式完全一样。</p>
<p><img src="/images/locust-start.jpg" alt></p>
<h2 id="优化1：自动生成locustfile"><a href="#优化1：自动生成locustfile" class="headerlink" title="优化1：自动生成locustfile"></a>优化1：自动生成locustfile</h2><p>通过前面的探索实践，我们基本上就实现了一份测试用例同时兼具接口自动化测试和接口性能测试的功能。</p>
<p>然而，在使用上还不够便捷，主要有两点：</p>
<ul>
<li>需要手工修改模板文件中的<code>testcase_file_path</code>路径；</li>
<li><code>locustfile.py</code>模板文件的路径必须放在<code>ApiTestEngine</code>的项目根目录下。</li>
</ul>
<p>于是，我产生了让<code>ApiTestEngine</code>框架本身自动生成<code>locustfile.py</code>文件的想法。</p>
<p>在实现这个想法的过程中，我想过两种方式。</p>
<p>第一种，通过分析<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码，可以看到<code>Locust</code>在<code>main.py</code>中具有一个<code>load_locustfile</code>方法，可以加载Python格式的文件，并提取出其中的<code>locust_classes</code>（也就是<code>Locust</code>的子类）；后续，就是将<code>locust_classes</code>作为参数传给<code>Locust</code>的<code>Runner</code>了。</p>
<p>若采用这种思路，我们就可以实现一个类似<code>load_locustfile</code>的方法，将<code>YAML/JSON</code>文件中的内容动态生成<code>locust_classes</code>，然后再传给<code>Locust</code>的<code>Runner</code>。这里面会涉及到动态地创建类和添加方法，好处是不需要生成<code>locustfile.py</code>中间文件，并且可以实现最大的灵活性，但缺点在于需要改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的源码，即重新实现<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的<code>main.py</code>中的多个函数。虽然难度不会太大，但考虑到后续需要与<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的更新保持一致，具有一定的维护工作量，便放弃了该种方案。</p>
<p>第二种，就是生成<code>locustfile.py</code>这样一个中间文件，然后将文件路径传给<code>Locust</code>。这样的好处在于我们可以不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的任何地方，直接对其进行使用。与<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的传统使用方式差异在于，之前我们是在<code>Terminal</code>中通过参数启动<code>Locust</code>，而现在我们是在<code>ApiTestEngine</code>框架中通过Python代码启动<code>Locust</code>。</p>
<p>具体地，我在<code>setup.py</code>的<code>entry_points</code>中新增了一个命令<code>locusts</code>，并绑定了对应的程序入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">    <span class="string">'console_scripts'</span>: [</span><br><span class="line">        <span class="string">'ate=ate.cli:main_ate'</span>,</span><br><span class="line">        <span class="string">'locusts=ate.cli:main_locust'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ate/cli.py</code>中新增了<code>main_locust</code>函数，作为<code>locusts</code>命令的入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Performance test with locust: parse command line options and run commands.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> locust.main <span class="keyword">import</span> main</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        print(<span class="string">"Locust is not installed, exit."</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    sys.argv[<span class="number">0</span>] = <span class="string">'locust'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        sys.argv.extend([<span class="string">"-h"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">"-h"</span>, <span class="string">"--help"</span>, <span class="string">"-V"</span>, <span class="string">"--version"</span>]:</span><br><span class="line">        main()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        testcase_index = sys.argv.index(<span class="string">'-f'</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> testcase_index &lt; len(sys.argv)</span><br><span class="line">    <span class="keyword">except</span> (ValueError, AssertionError):</span><br><span class="line">        print(<span class="string">"Testcase file is not specified, exit."</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    testcase_file_path = sys.argv[testcase_index]</span><br><span class="line">    sys.argv[testcase_index] = parse_locustfile(testcase_file_path)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>若你执行<code>locusts -V</code>或<code>locusts -h</code>，会发现效果与<code>locust</code>的特性完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -V</span><br><span class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout: Locust 0.8a2</span><br><span class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout:</span><br></pre></td></tr></table></figure>

<p>事实上，通过上面的代码（<code>main_locust</code>）也可以看出，<code>locusts</code>命令只是对<code>locust</code>进行了一层封装，用法基本等价。唯一的差异在于，当<code>-f</code>参数指定的是<code>YAML/JSON</code>格式的用例文件时，会先转换为Python格式的<code>locustfile.py</code>，然后再传给<code>locust</code>。</p>
<p>至于解析函数<code>parse_locustfile</code>，实现起来也很简单。我们只需要在框架中保存一份<code>locustfile.py</code>的模板文件（<code>ate/locustfile_template</code>），并将<code>testcase_file_path</code>采用占位符代替。然后，在解析函数中，就可以读取整个模板文件，将其中的占位符替换为<code>YAML/JSON</code>用例文件的实际路径，然后再保存为<code>locustfile.py</code>，并返回其路径即可。</p>
<p>具体的代码就不贴了，有兴趣的话可自行查看。</p>
<p>通过这一轮优化，<code>ApiTestEngine</code>就继承了<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>的全部功能，并且可以直接指定<code>YAML/JSON</code>格式的文件启动<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>执行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml</span><br><span class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>

<h2 id="优化2：一键启动多个locust实例"><a href="#优化2：一键启动多个locust实例" class="headerlink" title="优化2：一键启动多个locust实例"></a>优化2：一键启动多个locust实例</h2><p>经过第一轮优化后，本来应该是告一段落了，因为此时<code>ApiTestEngine</code>已经可以非常便捷地实现接口自动化测试和接口性能测试的切换了。</p>
<p>直到有一天，在<code>TesterHome</code>论坛讨论<code>Locust</code>的一个<a href="https://testerhome.com/topics/9277#reply-84542" target="_blank" rel="noopener">回复</a>中，<a href="https://testerhome.com/keithmork" target="_blank" rel="noopener"><code>@keithmork</code></a>说了这么一句话。</p>
<blockquote>
<p>期待有一天<code>ApiTestEngine</code>的热度超过<code>Locust</code>本身</p>
</blockquote>
<p>看到这句话时我真的不禁泪流满面。虽然我也是一直在用心维护<code>ApiTestEngine</code>，却从未有过这样的奢望。</p>
<p>但反过来细想，为啥不能有这样的想法呢？当前<code>ApiTestEngine</code>已经继承了<code>Locust</code>的所有功能，在不影响<code>Locust</code>已有特性的同时，还可以采用<code>YAML/JSON</code>格式来编写维护测试用例，并实现了一份测试用例可同时用于接口自动化和接口性能测试的目的。</p>
<p>这些特性都是<code>Locust</code>所不曾拥有的，而对于使用者来说的确也都是比较实用的功能。</p>
<p>于是，新的目标在内心深处萌芽了，那就是在<code>ApiTestEngine</code>中通过对<code>Locust</code>更好的封装，让<code>Locust</code>的使用者体验更爽。</p>
<p>然后，我又想到了自己之前做的一个开源项目，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>。当时做这个项目的初衷在于，当我们使用<code>Locust</code>进行压测时，要想使用压测机所有CPU的性能，就需要采用<code>master-slave</code>模式。因为<code>Locust</code>默认是单进程运行的，只能运行在压测机的一个CPU核上；而通过采用<code>master-slave</code>模式，启动多个<code>slave</code>，就可以让不同的<code>slave</code>运行在不同的CPU核上，从而充分发挥压测机多核处理器的性能。</p>
<p>而在实际使用<code>Locust</code>的时候，每次只能手动启动<code>master</code>，并依次手动启动多个<code>slave</code>。若遇到测试脚本调整的情况，就需要逐一结束<code>Locust</code>的所有进程，然后再重复之前的启动步骤。如果有使用过<code>Locust</code>的同学，应该对此痛苦的经历都有比较深的体会。当时也是基于这一痛点，我开发了<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>，目的就是可以一次性启动或销毁多个<code>Locust</code>实例。这个脚本做出来后，自己用得甚爽，也得到了<code>Github</code>上一些朋友的青睐。</p>
<p>既然现在要提升<code>ApiTestEngine</code>针对<code>Locust</code>的使用便捷性，那么这个特性毫无疑问也应该加进去。就此，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="noopener"><code>debugtalk/stormer</code></a>项目便被废弃，正式合并到<code>debugtalk/ApiTestEngine</code>。</p>
<p>想法明确后，实现起来也挺简单的。</p>
<p>原则还是保持不变，那就是不改变<a href="http://locust.io/" target="_blank" rel="noopener"><code>Locust</code></a>本身的特性，只在传参的时候在中间层进行操作。</p>
<p>具体地，我们可以新增一个<code>--full-speed</code>参数。当不指定该参数时，使用方式跟之前完全相同；而指定<code>--full-speed</code>参数后，就可以采用多进程的方式启动多个实例（实例个数等于压测机的处理器核数）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do original work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"--full-speed"</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">        locusts.run_locusts_at_full_speed(sys.argv)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        locusts.main()</span><br></pre></td></tr></table></figure>

<p>具体实现逻辑在<code>ate/locusts.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> locust.main <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_master</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.append(<span class="string">"--master"</span>)</span><br><span class="line">    sys.argv = sys_argv</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_slave</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.extend([<span class="string">"--slave"</span>])</span><br><span class="line">    sys.argv = sys_argv</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_locusts_at_full_speed</span><span class="params">(sys_argv)</span>:</span></span><br><span class="line">    sys_argv.pop(sys_argv.index(<span class="string">"--full-speed"</span>))</span><br><span class="line">    slaves_num = multiprocessing.cpu_count()</span><br><span class="line"></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(slaves_num):</span><br><span class="line">        p_slave = multiprocessing.Process(target=start_slave, args=(sys_argv,))</span><br><span class="line">        p_slave.daemon = <span class="literal">True</span></span><br><span class="line">        p_slave.start()</span><br><span class="line">        processes.append(p_slave)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_master(sys_argv)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>由此可见，关键点也就是使用了<code>multiprocessing.Process</code>，在不同的进程中分别调用<code>Locust</code>的<code>main()</code>函数，实现逻辑十分简单。</p>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p>经过前面的优化，采用<code>ApiTestEngine</code>执行性能测试时，使用就十分便捷了。</p>
<p>安装<code>ApiTestEngine</code>后，系统中就具有了<code>locusts</code>命令，使用方式跟<code>Locust</code>框架的<code>locust</code>几乎完全相同，我们完全可以使用<code>locusts</code>命令代替原生的<code>locust</code>命令。</p>
<p>例如，下面的命令执行效果与<code>locust</code>完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -V</span><br><span class="line">$ locusts -h</span><br><span class="line">$ locusts -f locustfile.py</span><br><span class="line">$ locusts -f locustfile.py --master -P 8088</span><br><span class="line">$ locusts -f locustfile.py --slave &amp;</span><br></pre></td></tr></table></figure>

<p>差异在于，<code>locusts</code>具有更加丰富的功能。</p>
<p>在<code>ApiTestEngine</code>中编写的<code>YAML/JSON</code>格式的接口测试用例文件，直接运行就可以启动<code>Locust</code>运行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml</span><br><span class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</span><br><span class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</span><br></pre></td></tr></table></figure>

<p>加上<code>--full-speed</code>参数，就可以同时启动多个<code>Locust</code>实例（实例个数等于处理器核数），充分发挥压测机多核处理器的性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ locusts -f examples/first-testcase.yml --full-speed -P 8088</span><br><span class="line">[2017-08-26 23:51:47,071] bogon/INFO/locust.main: Starting web monitor at *:8088</span><br><span class="line">[2017-08-26 23:51:47,075] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,078] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,080] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,083] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.runners: Client <span class="string">'bogon_656e0af8e968a8533d379dd252422ad3'</span> reported as ready. Currently 1 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_09f73850252ee4ec739ed77d3c4c6dba'</span> reported as ready. Currently 2 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.main: Starting Locust 0.8a2</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_869f7ed671b1a9952b56610f01e2006f'</span> reported as ready. Currently 3 clients ready to swarm.</span><br><span class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_80a804cda36b80fac17b57fd2d5e7cdb'</span> reported as ready. Currently 4 clients ready to swarm.</span><br></pre></td></tr></table></figure>

<p><img src="/images/locusts-full-speed.jpg" alt></p>
<p>后续，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="noopener"><code>ApiTestEngine</code></a>将持续进行优化，欢迎大家多多反馈改进建议。</p>
<p>Enjoy!</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/apitestengine-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/apitestengine-quickstart/" class="post-title-link" itemprop="url">ApiTestEngine QuickStart</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-20T00:00:00+08:00">2017-08-20</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/HttpRunner/" itemprop="url" rel="index"><span itemprop="name">HttpRunner</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introduction-to-Sample-Interface-Service"><a href="#Introduction-to-Sample-Interface-Service" class="headerlink" title="Introduction to Sample Interface Service"></a>Introduction to Sample Interface Service</h2><p>Along with this project, I devised a sample interface service, and you can use it to familiarize how to play with <code>ApiTestEngine</code>.</p>
<p>This sample service mainly has two parts:</p>
<ul>
<li>Authorization, each request of other APIs should sign with some header fields and get token first.</li>
<li>RESTful APIs for user management, you can do CRUD manipulation on users.</li>
</ul>
<p>As you see, it is very similar to the mainstream production systems. Therefore once you are familiar with handling this demo service, you can master most test scenarios in your project.</p>
<h2 id="Launch-Sample-Interface-Service"><a href="#Launch-Sample-Interface-Service" class="headerlink" title="Launch Sample Interface Service"></a>Launch Sample Interface Service</h2><p>The demo service is a flask server, we can launch it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export FLASK_APP=tests/api_server.py</span><br><span class="line">$ flask run</span><br><span class="line"> * Serving Flask app &quot;tests.api_server&quot;</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>

<p>Now the sample interface service is running, and we can move on to the next step.</p>
<h2 id="Capture-HTTP-request-and-response"><a href="#Capture-HTTP-request-and-response" class="headerlink" title="Capture HTTP request and response"></a>Capture HTTP request and response</h2><p>Before we write testcases, we should know the details of the API. It is a good choice to use a web debugging proxy tool like <code>Charles Proxy</code> to capture the HTTP traffic.</p>
<p>For example, the image below illustrates getting token from the sample service first, and then creating one user successfully.</p>
<p><img src="/images/ate-quickstart-http-1.jpg" alt></p>
<p><img src="/images/ate-quickstart-http-2.jpg" alt></p>
<p>After thorough understanding of the APIs, we can now begin to write testcases.</p>
<h2 id="Write-the-first-test-case"><a href="#Write-the-first-test-case" class="headerlink" title="Write the first test case"></a>Write the first test case</h2><p>Open your favorite text editor and you can write test cases like this.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">ios</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="number">19067</span><span class="string">cf712265eb5426db8d3664026c1ccea02b9</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">F8prvGryC5beBr4g</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>As you see, each API request is described in a <code>test</code> block. And in the <code>request</code> field, it describes the detail of HTTP request, includes url, method, headers and data, which are in line with the captured traffic.</p>
<p>You may wonder why we use the <code>json</code> field other than <code>data</code>. That’s because the post data is in <code>JSON</code> format, when we use <code>json</code> to indicate the post data, we do not have to specify <code>Content-Type</code> to be <code>application/json</code> in request headers or dump data before request.</p>
<p>Have you recalled some familiar scenes?</p>
<p>Yes! That’s what we did in <a href="requests.request"><code>requests.request</code></a>! Since <code>ApiTestEngine</code> takes full reuse of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>, it inherits all powerful features of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener"><code>Requests</code></a>, and we can handle HTTP request as the way we do before.</p>
<h2 id="Run-test-cases"><a href="#Run-test-cases" class="headerlink" title="Run test cases"></a>Run test cases</h2><p>Suppose the test case file is named as <code>quickstart-demo-rev-0.yml</code> and is located in <code>examples</code> folder, then we can run it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ate examples/demo-rev-0.yml</span><br><span class="line">Running tests...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</span><br><span class="line">INFO:root: status_code: 200, response_time: 48 ms, response_length: 46 bytes</span><br><span class="line">OK (0.049669)s</span><br><span class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</span><br><span class="line">ERROR:root: Failed to POST http://127.0.0.1:5000/api/users/1000! exception msg: 403 Client Error: FORBIDDEN for url: http://127.0.0.1:5000/api/users/1000</span><br><span class="line">ERROR (0.006471)s</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.056s</span><br><span class="line"></span><br><span class="line">FAILED</span><br><span class="line"> (Errors=1)</span><br></pre></td></tr></table></figure>

<p>Oops! The second test case failed with 403 status code.</p>
<p>That is because we request with the same data as we captured in <code>Charles Proxy</code>, while the <code>token</code> is generated dynamically, thus the recorded data can not be be used twice directly.</p>
<h2 id="Optimize-test-case-correlation"><a href="#Optimize-test-case-correlation" class="headerlink" title="Optimize test case: correlation"></a>Optimize test case: correlation</h2><p>To fix this problem, we should correlate <code>token</code> field in the second API test case, which is also called <code>correlation</code>.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">iOS/10.3</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">ios</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="number">19067</span><span class="string">cf712265eb5426db8d3664026c1ccea02b9</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="number">9</span><span class="string">TN6O2Bn1vzfybF</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>As you see, the <code>token</code> field is no longer hardcoded, instead it is extracted from the first API request with <code>extractors</code> mechanism. In the meanwhile, it is assigned to <code>token</code> variable, which can be referenced by the subsequent API requests.</p>
<p>Now we save the test cases to <code>quickstart-demo-rev-1.yml</code> and rerun it, and we will find that both API requests to be successful.</p>
<h2 id="Optimize-test-case-parameterization"><a href="#Optimize-test-case-parameterization" class="headerlink" title="Optimize test case: parameterization"></a>Optimize test case: parameterization</h2><p>Let’s look back to our test set <code>quickstart-demo-rev-1.yml</code>, and we can see the <code>device_sn</code> field is still hardcoded. This may be quite different from the actual scenarios.</p>
<p>In actual scenarios, each user’s <code>device_sn</code> is different, so we should parameterize the request parameters, which is also called <code>parameterization</code>. In the meanwhile, the <code>sign</code> field is calculated with other header fields, thus it may change significantly if any header field changes slightly.</p>
<p>However, the test cases are only <code>YAML</code> documents, it is impossible to generate parameters dynamically in such text. Fortunately, we can combine <code>Python</code> scripts with <code>YAML</code> test cases in <code>ApiTestEngine</code>.</p>
<p>To achieve this goal, we can utilize <code>import_module_functions</code> and <code>variables</code> mechanisms.</p>
<p>To be specific, we can create a Python file (<code>examples/utils.py</code>) and implement the related algorithm in it. Since we want to import this file, so we should put a <code>__init__.py</code> in this folder to make it as a Python module.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">SECRET_KEY = <span class="string">"DebugTalk"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sign</span><span class="params">(*args)</span>:</span></span><br><span class="line">    content = <span class="string">''</span>.join(args).encode(<span class="string">'ascii'</span>)</span><br><span class="line">    sign_key = SECRET_KEY.encode(<span class="string">'ascii'</span>)</span><br><span class="line">    sign = hmac.new(sign_key, content, hashlib.sha1).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> sign</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></span><br><span class="line">    random_char_list = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len):</span><br><span class="line">        random_char = random.choice(string.ascii_letters + string.digits)</span><br><span class="line">        random_char_list.append(random_char)</span><br><span class="line"></span><br><span class="line">    random_string = <span class="string">''</span>.join(random_char_list)</span><br><span class="line">    <span class="keyword">return</span> random_string</span><br></pre></td></tr></table></figure>

<p>And then, we can revise our demo test case and reference the functions. Suppose the revised file named <code>quickstart-demo-rev-2.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">examples.utils</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></span><br><span class="line"><span class="attr">        - device_sn:</span> <span class="string">$&#123;gen_random_string(15)&#125;</span></span><br><span class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></span><br><span class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">$user_agent</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">$os_platform</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="string">$app_version</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="string">$&#123;get_sign($user_agent,</span> <span class="string">$device_sn,</span> <span class="string">$os_platform,</span> <span class="string">$app_version)&#125;</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://127.0.0.1:5000/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>In this revised test case, we firstly import module functions in <code>import_module_functions</code> block by specifying the Python module path, which is relative to the current working directory.</p>
<p>To make fields like <code>device_sn</code> can be used more than once, we also bind values to variables in <code>variables</code> block. When we bind variables, we can not only bind exact value to a variable name, but also can call a function and bind the evaluated value to it.</p>
<p>When we want to reference a variable in the test case, we can do this with a escape character <code>$</code>. For example, <code>$user_agent</code> will not be taken as a normal string, and <code>ApiTestEngine</code> will consider it as a variable named <code>user_agent</code>, search and return its binding value.</p>
<p>When we want to reference a function, we shall use another escape character <code>${}</code>. Any content in <code>${}</code> will be considered as function calling, so we should guarantee that we call functions in the right way. At the same time, variables can also be referenced as parameters of function.</p>
<h2 id="Optimize-test-case-overall-config-block"><a href="#Optimize-test-case-overall-config-block" class="headerlink" title="Optimize test case: overall config block"></a>Optimize test case: overall config block</h2><p>There is still one issue unsolved.</p>
<p>The <code>device_sn</code> field is defined in the first API test case, thus it may be impossible to reference it in other test cases. Context separation is a well-designed mechanism, and we should obey this good practice.</p>
<p>To handle this case, overall <code>config</code> block is supported in <code>ApiTestEngine</code>. If we define variables or import functions in <code>config</code> block, these variables and functions will become global and can be referenced in the whole test set.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># examples/quickstart-demo-rev-3.yml</span></span><br><span class="line"><span class="attr">- config:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"smoketest for CRUD users."</span></span><br><span class="line"><span class="attr">    import_module_functions:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">examples.utils</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - device_sn:</span> <span class="string">$&#123;gen_random_string(15)&#125;</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        base_url:</span> <span class="attr">http://127.0.0.1:5000</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            device_sn:</span> <span class="string">$device_sn</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">get</span> <span class="string">token</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></span><br><span class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></span><br><span class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/get-token</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            user_agent:</span> <span class="string">$user_agent</span></span><br><span class="line"><span class="attr">            os_platform:</span> <span class="string">$os_platform</span></span><br><span class="line"><span class="attr">            app_version:</span> <span class="string">$app_version</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            sign:</span> <span class="string">$&#123;get_sign($user_agent,</span> <span class="string">$device_sn,</span> <span class="string">$os_platform,</span> <span class="string">$app_version)&#125;</span></span><br><span class="line"><span class="attr">    extractors:</span></span><br><span class="line"><span class="attr">        - token:</span> <span class="string">content.token</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">200</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.token"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"len_eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">16</span><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- test:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">create</span> <span class="string">user</span> <span class="string">which</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">/api/users/1000</span></span><br><span class="line"><span class="attr">        method:</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">            token:</span> <span class="string">$token</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></span><br><span class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></span><br><span class="line"><span class="attr">    validators:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"status_code"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="number">201</span><span class="string">&#125;</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;"check":</span> <span class="string">"content.success"</span><span class="string">,</span> <span class="string">"comparator"</span><span class="string">:</span> <span class="string">"eq"</span><span class="string">,</span> <span class="string">"expected"</span><span class="string">:</span> <span class="literal">true</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>As you see, we import public <code>Python</code> modules and variables in <code>config</code> block. Also, we can set <code>base_url</code> in <code>config</code> block, thereby we can only specify relative path in each API request url. Besides, we can also set common fields in <code>config</code> <code>request</code>, such as <code>device_sn</code> in headers.</p>
<p>Until now, the test cases are finished and each detail is handled properly.</p>
<h2 id="Run-test-cases-and-generate-report"><a href="#Run-test-cases-and-generate-report" class="headerlink" title="Run test cases and generate report"></a>Run test cases and generate report</h2><p>Finally, let’s run test set <code>quickstart-demo-rev-4.yml</code> once more.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ate examples/quickstart-demo-rev-4.yml</span><br><span class="line">Running tests...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</span><br><span class="line">INFO:root: status_code: 200, response_time: 33 ms, response_length: 46 bytes</span><br><span class="line">OK (0.037027)s</span><br><span class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</span><br><span class="line">INFO:root: status_code: 201, response_time: 15 ms, response_length: 54 bytes</span><br><span class="line">OK (0.016414)s</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.054s</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">Generating HTML reports...</span><br><span class="line">Template is not specified, load default template instead.</span><br><span class="line">Reports generated: /Users/Leo/MyProjects/ApiTestEngine/reports/quickstart-demo-rev-0/2017-08-01-16-51-51.html</span><br></pre></td></tr></table></figure>

<p>Great! The test case runs successfully and generates a <code>HTML</code> test report.</p>
<p><img src="/images/ate-quickstart-demo-report.jpg" alt></p>
<h2 id="Further-more"><a href="#Further-more" class="headerlink" title="Further more"></a>Further more</h2><p>This is just a starting point, see the <code>advanced guide</code> for the advanced features.</p>
<ul>
<li>templating</li>
<li>data extraction and validation</li>
<li><a href="https://github.com/debugtalk/ApiTestEngine/blob/master/docs/comparator.md" target="_blank" rel="noopener"><code>comparator</code></a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/d-test-hire-info/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/d-test-hire-info/" class="post-title-link" itemprop="url">【大疆内推】岗位描述我只想这么写</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-09T00:00:00+08:00">2017-08-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/6-Recommendation/" itemprop="url" rel="index"><span itemprop="name">6. Recommendation</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近期，大疆互联网事业部广招各路英豪，各类岗位都有大量的<code>Hire Count</code>。</p>
<p>在我们质量部，现急需招聘<code>软件测试工程师</code>、<code>测试开发工程师</code>和<code>QA</code>，名额无限制。</p>
<p>如果你对我们的岗位感兴趣，可能你还想了解如下信息。</p>
<h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>大疆这家公司我就不介绍了，大家有兴趣可以看下我们的<a href="http://www.dji.com/" target="_blank" rel="noopener">公司主页</a>，或者在网上自行搜索。</p>
<p>可能很多人都知道大疆是一家做无人机的公司，但却不知道我们一直在探索着与互联网各种跨界融合的方式，在移动互联网、云计算、大数据、物联网、电子商务等领域同样投入了大量的资源。而互联网事业部，则肩负着该项重要使命。</p>
<p>我们质量部作为互联网事业部的测试团队，对接了整个部门的所有产品和项目，一直致力于提升整个部门的软件质量的研发效率。</p>
<h2 id="岗位职责及要求"><a href="#岗位职责及要求" class="headerlink" title="岗位职责及要求"></a>岗位职责及要求</h2><p>当前我们有<code>测试</code>、<code>测试开发</code>、<code>QA</code>这三类岗位。</p>
<p>关于这三类岗位的职责和差异，基本上跟各大互联网公司的岗位对应。之前我在内部新员工培训时有过一次分享，并且整理成了一篇文章，<a href="https://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a>，大家如有兴趣，可以进一步了解。</p>
<p>而对于岗位的要求，我不想复制粘贴招聘信息上千篇一律的描述，我就只谈下我对每个岗位需求的理解。</p>
<p>对于测试工程师，最重要的莫过于熟悉业务、善于发现问题、跟进并推动问题的解决。对于两年工作经验以内的，我们看重基础，对计算机软件、网络、软件测试理论等方面能有较好的掌握，如果在工作中还能积极地学习新技术并在项目中尝试使用，会是一个不错的亮点。对于两年工作经验以上的，我们期望能对业务流程、测试工作本身有更深的理解，并且在软件测试技术方面有一定的积累，最好能有一些成功的实践经验。</p>
<p>对于测试开发工程师，我们重点关注两个方面，一是对测试本身的理解，最好能有比较丰富的业务测试经验，毕竟开发出来的工具还是要为业务测试服务的；另一方面，作为带有<code>开发</code>的title，希望也能有较好的代码能力，并且最好有成功的实践案例或作品。</p>
<p>对于QA，业务、流程、管理，以及有较强的推动能力。</p>
<p>不管是什么岗位，善于学习，乐于总结，具有写笔记或博客的习惯，都会是很大的加分项。</p>
<p>关于硬性条件这块儿，希望能是本科及以上学历，计算机相关专业。公司并没有严格限制学历，但是当学历不达标时，对工作背景以及其它方面会有更高的期望。</p>
<h2 id="薪资福利"><a href="#薪资福利" class="headerlink" title="薪资福利"></a>薪资福利</h2><p>对于薪资福利，不同岗位和级别会有一定差异，但不管是什么岗位，处于行业领先的薪资水平还是可以保障的。</p>
<p>年底有机会获得奔驰宝马福利车这种奖励可能会觉得离自己太遥远，但年终奖还是不错的，具体看绩效。</p>
<p>另外比较可喜的是，从公司不断增加的福利可以看到，公司也在一直致力于提升员工的各项软福利和归属感，各项规章管理制度也在日益完善和更加人性化。</p>
<p>除了单纯的薪资福利，相信公司业务迅猛发展带来的个人能力成长空间，也是你所期待的。在大疆，公司的口号是探索未来无限可能（The future of possible），这对员工个人来说，也同样适用。</p>
<h2 id="其它岗位"><a href="#其它岗位" class="headerlink" title="其它岗位"></a>其它岗位</h2><p>除了测试相关的岗位，我们在前后端开发、业务运维、运维开发等各个岗位都有海量的招聘需求。</p>
<p>如果你们有兴趣，我同样可以帮忙对接到各个岗位的负责人。</p>
<h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>可以直接发到我的邮箱：<a href="mailto:mail@debugtalk.com">mail@debugtalk.com</a><br>也可以发送到我的微信公众号：<code>DebugTalk</code></p>
<p>合适的简历我会积极内推，并全程跟进状态和进度。假如跟我们的岗位需求不匹配，我也会及时反馈结果及原因。</p>
<p>愿疆来有你，不管最后我们能否成为同事，希望我们都能成为朋友。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/xiaojianguo.jpg" alt="debugtalk">
            
              <p class="site-author-name" itemprop="name">debugtalk</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">95</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/debugtalk" title="GitHub &rarr; https://github.com/debugtalk" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mail@debugtalk.com" title="E-Mail &rarr; mailto:mail@debugtalk.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">debugtalk</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>







  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1257477005&web_id=1257477005"></script>
  </div>



        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  

  


  <script src="/js/src/bootstrap.js?v=7.0.1"></script>


  
  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
